# 컴퓨팅 사고력
## 프로그래밍과 논리/수학
### 논리(Hard Logic)의 정의
- 생각이나 주장의 타당성과 옳고 그름을 판별하는 규칙이나 원리를 의미
- 경험적, 직관적, 확률적 판단을 의미하는 soft logic에 반대되는 의미로 hard logic이라고 표현
- 맞는 이유와 틀린 이유를 정확히 밝히는 생각의 규칙

### 프로그래밍의 어려운 점
- 프로그래밍 언어 문법과 라이브러리 사용
  - 처음 보는 사람은 알 수 없음
  - 훈련에 비례해 실력이 늘게 됨

- 논리
  - 직관적인 접근을 논리로 착각하기 쉬움

### Soft Logic
- 직관은 논리적인 느낌을 주는 것
- 직관의 장점은 (익숙한 상황에서) 빠름
- 직관의 단점은 정확하지 않음 (가끔은 익숙한 상황에서도 틀림)
- 또 다른 단점은 강한 착각을 일으킨다는 것 

### Hard Logic vs Soft Logic
- 일상 생활
  - Soft Logic이 빠르기 때문에 유용함
  - 논리적으로 부정확한 표현을 사용하지만, 어떤 의미인지 모든 사람이 알고 있다는 가정이 존재함

- 프로그래밍
  - 프로그래밍 언어의 표현들이 모두 논리학에서 나온 것
  - 사용되는 수많은 알고리즘들을 이해하기 위해서는 Hard Logic이 필요함

- 문제에 대해 오해하는 경우
  - Soft Logic으로 알고리즘을 이해하려고 하는 경우
  - 알고리즘 설명을 보고 또 봐도 이해가 안되는 것은 증명을 안 봤기 때문
  - 증명을 봐도 이해가 인되는 것은 직관적으로 이해하려고 하기 때문
  - 가끔 직관적으로 이해되는 알고리즘이 있지만, 조금만 어려워지만 직관으로 완전한 이해를 얻는 것은 사실상 불가능함

---

## 명제
- 참이나 거짓으로 알 수 있는 식이나 문장
- p, q, r ... 로 표현

### 진릿값 
- 참이나 거짓을 표현
- T, F 또는 1, 0

### 명제의 연산(결합)
- 부정(NOT)
  - p가 명제일 때, 명제의 진릿값이 반대가 됨
  - ~p 또는 -p로 표기하고,not p 또는 p의 부정으로 읽음

- 논리곱(AND)
  - p, q가 명제일 때, p, q 모두 참일 때만 참이 되는 명제
  - p ^ q 로 표기하고, p and q 또는 p 그리고 q로 읽음

- 논리합(OR)
  - p, q가 명제일 때, p, q 모두 거짓일 때만 거짓이 되는 명제
  - p V q로 표현하고 p or q 나 p 또는 q로 읽음

- 베타적 논리합(XOR)
  - p, q가 명제일 때, p, q 중 하나만 참일 때 참이 되는 명제
  - p⊕q로 표기하고, p xor q 또는 p exclusive OR q로 읽음

### 조건 명제
- p, q가 명제일 때, 명제 p가 조건(원인), q가 결론(결과)으로 제시되는 명제
- p -> q (p이면 q이다)

* 원인이 거짓이면 결과는 항상 True

### 쌍방조건명제
- p, q가 명제일 때, 명제 p와 q가 모두 조건이면서 결론인 명제
- p <-> q (p면 q고, q면 p다)

* 둘다 T거나 F여야 True임 

### 조건명제의 역, 이, 대우
- 주어진 명제 : p -> q
- 역 : q -> p
- 이 : ~p -> ~q
- 대우 : ~q -> ~p

* 명제에서 설명하기 제일 쉬운 건 대우로 뒤집는 거 !

### 증명
- 직접 증명
  - p -> q가 참임을 증명하게 위해 p를 참으로 가정했을 때 q도 참임을 증명하는 방법
  - Trivial Proof(자명한 증명)
  - Vacuous Proof(공허한 증명)

- 간접 증명
  - 증명해야 하는 명제를 변형하여 증명하는 방법
  - 대우에 의한 증명
  - 모순에 의한 증명

- 수학적 귀납법
  - 일정한 규칙을 나타내는 명제 P(n)이 성립함을 증명하는 방법

- 귀류법



### Trivial Proof: ∀x, P(x) → Q(x)를 증명하려는데, Q(x)가 항상 참인 경우

- 다음 명제를 증명하시오

① 실수 x에 대해, 만약 x < -1이면 x² + ¼ > 0이다

:x² + 1/4 > 0, x² → -1/4이고, x는 실수이므로 Q(x)는 항상 참이다.  
따라서 ∀x, P(x) → Q(x) 이다.


② n이 홀수이면 4n³ + 6n² + 12는 짝수이다

: 4n³ + 6n² + 12 = 2(2n³ + 3n² + 6)이므로 4n³ + 6n² + 12는 짝수이다.  
그러므로 Q(x)는 항상 참이다.

따라서 ∀x, P(x) → Q(x) 이다.

* 직접 대입 같은 것을 통해서 증명하는 것



### Vacuous Proof: ∀x, P(x) → Q(x)를 증명하려는데, P(x)가 항상 거짓인 경우

- 다음 명제를 증명하시오

① 실수 x에 대해, 만약 2x² − 4x + 4 < 0이면 x > 8이다

: 2x² − 4x + 4 = 2(x² − 2x + 2) = 2((x−1)² + 1) ≥ 2 > 0 이다.  
따라서 2x² − 4x + 4 < 0 은 거짓이다.  
그렇기 때문에 P(x)는 거짓이므로 해당 명제 ∀x, P(x) → Q(x)는 참이다.


② 4n³ + 6n² + 11는 짝수이면 n이 홀수이다

: 4n³ + 6n² + 11 = 2(2n³ + 3n² + 5) + 1 이므로 4n³ + 6n² + 11은 홀수이다.  
그러므로 P(x)는 거짓이므로 해당 명제 ∀x, P(x) → Q(x)는 참이다.

* 증명할 필요도 없이 앞에 P(x)가 거짓임


### 수학적 귀납법과 증명의 수준

- 0보다 크거나 같은 정수 범위에 대해 P(n)이 성립함을 증명

- 수학적 귀납법의 기본형:
  - P(1)이 참이고, P(n) → P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.

- 수학적 귀납법의 강한 형태:
  - P(1)이 참이고, P(1) ∧ P(2) ∧ ... ∧ P(n) → P(n+1)이 참이면 P(n)은 모든 자연수 n에 대해서 참이다.

* 귀납법은 P(1)이 참이라는 것을 먼저 증명


- 상세한 증명을 하려면 단순히 “답이 맞는 것이 당연하다”라고 말하는 것으로는 충분하지 않음
  - **증명이 가능한 명제를 만들어야 함.**
  - 이 경우 증명이 가능한 명제는 다음과 같음:  
    > “sum(x)가 리턴하는 값은 1 + 2 + ⋯ + x의 값과 항상 같다”

- 이제 수학적 귀납법을 적용할 수 있음.
  - **P(1)이 참이다**:  
    “sum(1)이 리턴하는 값은 1이다”를 증명하면 됨.  
    실제 코드에 1을 대입하면 1을 리턴함을 알 수 있음.

```python
sum(1)
if (x <= 0) return 0
return 1 + sum(0)
```

- 임의의 값 k에 대해 P(k)가 참이라고 가정한다.  
: `sum(k)`가 `1 + 2 + ⋯ + k`를 리턴

- k + 1에 대해 P(k+1)이 참임을 증명한다.

---

```python
def sum(k+1):
    if (k+1 <= 0):
        return 0
    return (k+1) + sum(k)
```

임의의 값 k에 대해 P(k)가 참이라고 가정한다.  
: `sum(k)`가 `1 + 2 + ⋯ + k`를 리턴

k + 1에 대해 P(k+1)이 참임을 증명한다.

---

## 함수 정의
```python
def sum(k+1):
    if (k+1 <= 0):
        return 0
    return (k+1) + sum(k)
```

- sum(k)는 1 + 2 + ⋯ + k라고 가정했으므로,
- sum(k+1) = 1 + 2 + ⋯ + k + (k+1)을 리턴.
- 따라서 P(k+1)이 참이다.


### 약간의 설명

- 컴퓨터는 0/1을 표현할 수 있는 비트들을 모아 수를 표현
- k개의 비트를 사용하면 0부터 2^k - 1까지 표현 가능
- 사실, 꼭 저 범위인 것은 아님. 약속하는 방식에 따라 다르지만, 최대 2^k 가지의 값을 표현하는 것이 가능
- 10진수로 k자리를 쓰면 0부터 10^k - 1까지 표현이 가능한 것과 완전히 동일한 과정
- 어떤 값 n을 표현하기 위해서는 몇 개의 비트가 필요할까?
  - `2^k - 1 ≥ n` 이 성립해야 한다.  
    → 즉, `2^k ≥ n + 1`

  - 같은 의미로,  
    `k ≥ log(n+1)` → 약 `log n` 비트가 필요


- `x = log n` 과 `2^x = n` 은 같은 말
