# Graph
## 그래프의 기본과 탐색
### 그래프 
- 아이템(사물 또는 추상적 개념)들과 이들 사이의 연결 관계를 표현
- 선형 자료구조나 트리 자료구조로 표한하기 어려운 N:N 관계를 가지는 원소들을 표현하기에 용이함

- 정점(Vertex)들의 집합과 이들을 연결하는 간선(Edge)들의 집합으로 구성된 자료 구조

  - |V| : 정점의 개수, |E| : 그래프에 포함된 간선의 개수라 할 때,
    |V| 개의 정점을 가지는 그래프는 최대 |E| = |V| * (|V| - 1) / 2개의 간선을 가질 수 있음 (하나의 정점, 갈 수 있는 다른 정점)

- 예) 5개 정점이 있는 그래프의 최대 간선 수는 10 (= 5 * 4 / 2)개

### 그래프 유형 
- 무향(무방향) 그래프(Undirected Graph) = 양방향 그래프
- 유향(방향) 그래프(Directed Graph)
- 가중치 그래프(Weighted Graph) - 거리, 비용, 시간 , 무게 등
- 사이클 없는 방향 그래프(DAG, Directed Acyclic Graph) - 트리(이진 트리)
* 사이클 : 한 노드에서 시작해서 한 번씩만 다른 노드를 방문하고 자기 자신에게 돌아오는 것

- 완전 그래프 : 정점들에 대해 가능한 모든 간선들을 가진 그래프
- 부분 그래프 : 원래 그래프에서 일부의 정점이나 간선을 제외한 그래프
- 희소 그래프 : 간선이 적은 그래프

### 인접 정점
- 인접(Adjacency)
  - 두 개의 정점에 간선이 존재(연결됨)하면 서로 인접해 있다고 함
  - 완전 그래프에 속한 임의의 두 정점들은 모두 인접해 있음 

### 그래프 경로
- 경로란 간선들을 순서대로 나열한 것
- 경로 중 한 정점을 최대한 한 번만 지나는 경로를 **단순경로**라고 함 
- 시작한 정점에서 끝나는 경로를 **사이클(Cycle)**이라고 함

### 그래프 표현
- 간선의 정보를 저장하는 방식, 메모리나 성능을 고려해서 결정
- 인접 행렬(Adjacent matrix)
  - |V| x |V| 크기의 2차원 배열을 이용해서 간선 정보를 저장

- 인접 리스트(Adjacent List)
  - 각 정점마다 해당 정점과 인접한 정점 정보를 저장

- 간선의 배열
  - 간선(시작 정점, 끝 정점)을 배열에 연속적으로 저장 

### 인접 행렬 : 두 정점을 연결하는 간선의 유무를 행렬로 표현
- |V| x |V| 정방 행렬
- 행 번호와 열 번호는 그래프의 정점에 대응
- 두 정점이 인접되어 있으면 1, 그렇지 않으면 0으로 표현
- 무향 그래프 
  - i번째 행의 합 = i번째 열의 합 = Vi의 차수 
- 유향 그래프
  - 행 i의 합 = Vi의 진출 차수
  - 열 i의 합 = Vi의 진입 차수

### 인접 행렬의 단점은 ? 
- 정점 수에 비해 간선 수가 적은 경우 공간 낭비가 심함
- 대신 특정 연결 정보 조회가 빠름

### 인접 리스트
- 각 정점에 대한 인접 정점들을 순차적으로 표현 (연결 안된 정보는 다 버림)
- 하나의 정점에 대한 인접 정점들을 각각 노드로 하는 연결 리스트로 저장
- (장점) 메모리 효율적, (단점) 특정 연결 정보 조회가 느림


* 무향 그래프의 인접 리스트 
  - 무방향 그래프 노드 수 = 간선의 수 * 2
  - 각 정점의 노드 수 = 정점의 차수

* 유향 그래프의 인접 리스트
  - 방향 그래프 노드 수 = 간선의 수
  - 각 정점의 노드 수 = 정점의 진출 차수

---

## DFS(Depth First Search, 깊이 우선 탐색)알고리즘 
- 모든 정점을 중복없이 빠짐없이 방문하는 경우
  - G : 탐색할 그래프
  - v : 방문하는 정점


### 중복 검사가 필요 없는 DFS
  - 스택에 push된 정점을 visited에 표시함


### Stack vs 재귀호출 
- 재귀호출
  - 장점 : 구현이 쉽다
  - 단점 : 느리다 + 재귀 깊이 제한

- stack
  - 장점 : 빠르다
  - 단점 : 구현이 어렵다
---

## BFS(Breadth First Search, 너비 우선 탐색) 알고리즘

- visited 처리 할 때는 큐에 추가할 때 같이 처리해주는 게 좋음
- 꺼낼 때 하면 혹시나 중복되는 문제가 생길 수 있음

---

### DFS vs BFS
- 둘 다 완전탐색
 
* DFS 
  - 경로를 출력
  - 갈 수 있는 경로의 수

* BFS
  - 몇 번 만에 가는지 
  - 최단 거리


### 🚇 지하철 노선도 문제: 왜 BFS를 써야 할까?

### 1. 문제 조건

* **정점(Vertex)**: 지하철 역
* **간선(Edge)**: 역과 역을 잇는 노선
* **조건**: 환승이 가능하면 **무조건 환승**
* 목표: **최소 환승 횟수** or **최단 경로** 찾기

---

### 2. DFS (깊이 우선 탐색)

* 한 경로를 끝까지 탐색 후 돌아옴.
* **문제점**:

  * 먼 길을 먼저 탐색할 수 있음.
  * 최단 환승/최소 경로 보장 ❌
  * 모든 경로를 다 탐색해야 함 → 비효율적.

👉 DFS는 **단순 경로 존재 여부 확인**에는 적합하지만, 최단 거리 문제엔 부적합.

---

### 3. BFS (너비 우선 탐색)

* 가까운 역부터 차례대로 탐색 (큐 사용).
* **장점**:

  * 먼저 도착한 경로가 곧 **최단 경로**.
  * 환승을 가중치 1로 처리하면, BFS는 **최소 환승 횟수 보장**.
  * 조건 “환승이 가능하면 무조건 환승”을 자연스럽게 만족.

👉 BFS는 **최소 단계** 문제(최소 환승, 최단 거리)에 적합.

---

## ✅ 결론

* **DFS**: 모든 경로 탐색 → 최단/최소 보장 안 됨.
* **BFS**: 가까운 곳부터 차례대로 탐색 → 최단 거리/최소 환승 보장.
* 따라서 지하철 문제(환승 최소화)에서는 **BFS 사용이 필수**.

---


## Union-Find(Disjoint set)
### 서로 소 집합(Disjoint-sets)
- 서로 공통 원소가 없는 집합
  - 교집합이 없는 집합들

- 대표자(representative)
  - 각 집합을 대표하는 하나의 원소를 말함

- 상호 배타 집합 
  - 확률, 논리, 집합론에서 동시에 일어날 수 없는 경우, 공통이 없는 경우를 말함
  - 집합론에서는 **서로 소와 같은 뜻**으로 사용됨

- 표현 방법
  - 연결리스트로 표현할 수 있음
  - 트리를 이용해 표현할 수 있음

### 서로 소 집합 연산
- Make-Set(x)
  - x를 원소로 가진 집합을 만듦
- Find-Set(x)
  - x가 속한 집합의 대표 원소를 반환
- Union(x, y)
  - y가 속한 집합과 x가 속한 집합의 합집합을 만듦
  - x가 합집합의 대표원소가 됨


### 상호배타 집합 예

* `Make-Set(x)`
* `Make-Set(y)`
* `Make-Set(a)`
* `Make-Set(b)`
* `Union(x, y)`
* `Union(a, b)`
* `Find-Set(x)` → x
* `Find-Set(b)` → a
* `Union(x, a)`


```
Make-Set(x) ~ (b)

(x)   (y)   (a)   (b)
```

➡️ `Union(x, y)`

```
(x y)   (a)   (b)
```

➡️ `Union(a, b)`

```
(x y)   (a b)
```

➡️ `Union(x, a)`

```
(x y a b)
```

---

* `Make-Set` : 각각의 원소를 독립적인 집합으로 생성
* `Union` : 두 집합을 합침
* `Find-Set` : 특정 원소가 속한 집합의 대표 원소(루트)를 반환

