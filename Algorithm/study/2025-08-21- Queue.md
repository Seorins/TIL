# BFS
### 그래프를 탐색하는 방법
- 너비 우선 탐색(Breadth First Search, BFS)
- 깊이 우선 탐색(Depth First Search, DFS)

### 너비우선탐색(BFS)의 개념
- 탐색 시작점의 인접한 정점들을 모두 차례로 방문한 후에 방문했던 정점을 시작점으로 하여 다시 인접한 정점들을 차례로 방문하는 방식
- 인접한 정점들에 대해 탐색을 한 후, 차례로 다시 너비우선탐색을 진행해야 하므로, 선입선출 형태의 자료구조인 큐를 활용함

- DFS(깊이 우선 탐색)는 한 갈래로 쭉 파고드는 방식
- BFS는 동심원처럼 넓게 퍼져나가며 탐색하는 방식


### BFS 동작 원리

1. 시작 정점을 큐에 삽입
2. 큐에서 원소를 꺼냄 → 방문하지 않았다면 방문 처리
3. 해당 정점과 연결된 인접 정점들을 큐에 삽입 (아직 방문 안 한 것만)
4. 큐가 빌 때까지 반복

# BFS 알고리즘

- **입력 파라미터** : 그래프 G와 탐색 시작점 v

```python
def bfs(G, v):  # 그래프 G, 탐색 시작점 v
    visited = [0] * (n+1)   # n: 정점의 개수
    queue = []              # 큐 생성
    queue.append(v)         # 시작점 v를 큐에 삽입
    
    while queue:            # 큐가 비어있지 않은 경우
        t = queue.pop(0)    # 큐의 첫 번째 원소 반환
        if not visited[t]:  # 방문되지 않은 곳이라면
            visited[t] = True   # 방문한 것으로 표시
            visit(t)            # 정점 t에서 할 일
            for i in G[t]:      # t와 연결된 모든 정점에 대해
                if not visited[i]:   # 방문되지 않은 곳이라면
                    queue.append(i)  # 큐에 넣기
```

### BFS의 특징
- 최단 거리 보장: BFS는 "간선의 가중치가 동일할 때" 최단 경로 탐색에 적합
- 시간복잡도: O(V + E)
  - V = 정점의 개수
  - E = 간선의 개수
- 활용:
  - 최단 경로 문제 (미로 탐색, 게임 맵 탐색)
  - 네트워크 연결 탐색
  - SNS 친구 관계 탐색

---

## DFS vs BFS 비교

### 1. DFS (깊이 우선 탐색)
- **스택(Stack)** 또는 **재귀(Recursion)** 사용
- 한 갈래로 **끝까지 내려간 후(backtracking)** 다시 올라옴

```python
def dfs(G, v, visited):
    visited[v] = True
    print(v, end=" ")   # 정점 방문 출력

    for nxt in G[v]:
        if not visited[nxt]:
            dfs(G, nxt, visited)
```


### 2. BFS (너비 우선 탐색)
- **큐(Queue)** 사용
- 가까운 노드부터 차례대로 탐색 → **넓게 확장**

```python
from collections import deque

def bfs(G, start):
    visited = [False] * (len(G) + 1)
    queue = deque([start])
    visited[start] = True

    while queue:
        v = queue.popleft()   # 큐에서 꺼내기
        print(v, end=" ")

        for nxt in G[v]:
            if not visited[nxt]:
                queue.append(nxt)
                visited[nxt] = True
```

## 4. 예시 그래프 탐색

그래프 (시작: 1)

1
├─ 2
│ ├─ 4
│ └─ 5
└─ 3
├─ 6
└─ 7

- **DFS 출력**: `1 2 4 5 3 6 7`  
- **BFS 출력**: `1 2 3 4 5 6 7`

---

## DFS vs BFS 활용 구분
### DFS (깊이 우선 탐색)
- 특징: 끝까지 파고들어서 탐색 → 재귀/스택

### 언제 쓰나?
- 모든 경로를 탐색해야 할 때
  - 예: 미로의 모든 가능한 경로 찾기
  - 순열, 조합, 백트래킹 문제
- 조건 만족하는 경우의 수를 세야 할 때
  - 예: 특정 목적지까지 가는 방법의 수 세기
  - N-Queen, Sudoku 같은 제약 충족 문제
- 도달 여부 확인
  - 그냥 "갈 수 있는가? (Yes/No)" 만 중요하면 DFS도 충분

### BFS (너비 우선 탐색)
- 특징: 가까운 곳부터 차례로 탐색 → 큐

### 언제 쓰나?
- 최단 거리를 찾아야 할 때
  - 예: 미로에서 출발 → 도착까지 최소 이동 횟수
  - 게임 맵에서 최소 턴 수
- 레벨 단위 탐색이 필요할 때
  - 예: 네트워크에서 "몇 단계 거쳐 연결되는지" 확인
  - SNS에서 친구 추천 (친구의 친구)
- 최소 비용 경로 (가중치 없는 경우)
  - BFS는 가중치가 모두 동일할 때 최단 경로를 보장

---

### BFS 사고 순서 요약 

1. 이 문제를 그래프로 보면 정점과 간선은 뭘까?
2. BFS 결과로 뭘 구해야 하지? (도달 여부 / 최단 거리 / 전체 탐색)
3. 큐 + visited 준비했나?
4. 시작점 큐에 넣고 방문 처리 했나?
5. while문 안에서 인접 노드 생성 규칙 제대로 만들었나?
6. 종료 조건이 맞나? (도착 시 바로 return? 아니면 다 탐색?)