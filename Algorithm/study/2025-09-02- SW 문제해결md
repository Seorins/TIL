# SW 문제해결
### SW 문제해결 역량이란?
- 프로그램을 하기 위한 많은 제약 조건과 요구 사항을 이해하고 최선의 방법을 찾아내는 능력
- 흐로그래머가 사용하는 언어나 라이브러리, 자료구조, 알고리즘에 대한 지식을 적재적소에 퍼즐을 배치하듯 이들을 연결하여 큰 그림을 만드는 능력이라 할 수 있음 
- 문제해결 역량은 추상적인 기술임
  - 프로그래밍 언어, 알고리즘처럼 명확히 정의된 실체가 없음
  - 무작정 알고리즘을 암기하고 문제를 풀어본다고 향상되지 않음
- 문제해결 역량을 향상시키기 위해 훈련이 필요함

### 문제해결 과정
1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다.
3. 어떻게 해결할지 계획을 세운다. 
  => 1. 자료구조 2. 알고리즘 확정 후 슈도코드 작성
4. 계획을 검증한다.
  => 복잡도와 관련해서 검증 
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

### 리스트에 숫자 넣기
- 수 N을 입력 받는다
- 윗 줄에는 N부터 1씩 증가되는 숫자 4개를 왼쪽에 채운다
- 아랫 줄에는 N부터 1씩 감소되는 숫자 4개를 오른쪽에 채운다
- 최종 결과룰를 출력한다. 빈 공간은 0으로 출력한다. 

* 어떤 거 써볼 수 있을까?
- 자료구조 : 2차원 리스트, 문자열
- 단순 출력이니 range만 써도 충분함
- 무엇이 효울적일지 생각해보기

### SW 문제해결 능력을 기르는 이유
- 코딩을 더 잘하게 하는 능력을 기르기 위함
- 기본문법 & 자료구조 & 알고리즘을 더 능숙하게 쓸 수 있도록 훈련함

### 문제를 잘 풀기 위한 전략
- 단계 1 : 완벽한 문제 이해
- 단계 2 : 종이와 펜을 이용한 설계하기 (어떻게 구현할지 계획하기)
- 단계 3 : 설계 한대로 구현 & 디버깅 하기

---

## 복잡도 분석
### 알고리즘이란?
- 유한한 단계를 통해 문제를 해결하기 위한 절차나 방법
  - 주로 컴퓨터용어로 쓰이며, 컴퓨터가 어떤 일을 수행하기 위한 단계적 방법을 말함
- 간단하게 다시 말하면 어떠한 문제를 해결하기 위한 절차라고 볼 수 있음

### 알고리즘의 효율
- 공간적 효율성과 시간적 효율성
  - **공간적 효율성**은 알고리즘이 **필요로 하는 메모리 공간**을 말함
  - **시간적 효율성**은 알고리즘이 작업을 완료하는 데 **걸리는 시간**을 말함
  - 효율성을 뒤집어 표현하면 복잡도(Complexity)가 됨. **복잡도가 높을수록 효율성은 저하됨**

  => 시간적 효율성은 주로 입력 크기 n에 대한 연산 횟수로 나타냄

### 복잡도의 점근적 표기
- 시간(또는 공간) 복잡도는 입력 크기에 대한 함수로 표기
  - 이 함수는 주로 여러 개의 항을 가지는 다항식
  - 이를 단순한 함수로 표현하기 위해 점근적 표기(Asysmptotic Notation)를 사용

- 입력 크기 n이 무한대로 커질 때의 복잡도를 간단히 표현하기 위해 사용하는 표기법
  - O(Big-Oh) -표기 (최악)
  - Ω(Big-Omega) -표기 (최선)
  - Θ(Big-Theta) -표기 (평균)

=> 항상 최악을 가정하고 연산을 계산해야함 

### O(Big-Oh) -표기
- **O-표기**는 복잡도의 점근적 상한을 나타냄
- 예: 복잡도가 `f(n) = 2n² - 7n + 4` 이라면, `f(n)`의 O-표기는 **O(n²)**
- 먼저 `f(n)`의 단순화된 표현은 `n²`
- 단순화된 함수 `n²`에 임의의 상수 `c`를 곱한 `c·n²`이 `n`이 증가함에 따라 `f(n)`의 상한이 된다.  
  (단, `c > 0`)

-> 상수 횟수만큼 반복하는 경우 빅오표기법 : O(1)

---

* O(N) vs O(1) ?

=> 뭐가 더 좋은지는 알 수 없음
=> N의 범위에 따라서 달라질 수 있음

* O(N) vs O(N^2) ?

=> N이 1 초과라면 O(N)이 더 좋음
=> 따라서 항상 빅오 표기법을 볼 때는 **N의 범위**를 잘 체크해야함! 

---

### 빅오표기법 표현 방법
- O(5N)
  - 정확한 배수를 강조하고 싶은 경우라면
  - O(N) 대신 O(5N)으로 표현할 수 있음

### 자주 사용하는 O-표기
- **O(1)** : 상수 시간 (Constant time)
- **O(log n)** : 로그(대수) 시간 (Logarithmic time)
=> 탐색 범위가 반으로 줄어들 때 
- **O(n)** : 선형 시간 (Linear time)
- **O(n log n)** : 로그 선형 시간 (Log-linear time)
- **O(n²)** : 제곱 시간 (Quadratic time)
- **O(n³)** : 세제곱 시간 (Cubic time)

### 복잡도 비교
- **O(log N)** 은 **O(1)** 보다는 느리지만, N이 작은 경우 유사한 성능
- **O(N log N)** 은 **O(N)** 보다는 느리지만, N이 작은 경우 유사한 성능

### 왜 효율적인 알고리즘이 필요한가?

- **예시**  
  10억 개의 숫자를 정렬하는데 PC에서 `O(n²)` 알고리즘은 **300여 년**이 걸리는 반면,  
  `O(n log n)` 알고리즘은 **5분** 만에 정렬함.

| 알고리즘 | 환경   | 1,000 | 1백만 | 10억 |
|----------|--------|-------|-------|------|
| **O(n²)** | PC     | < 1초 | 2시간  | 300년 |
|          | 슈퍼컴 | < 1초 | 1초    | 1주일 |
| **O(n log n)** | PC     | < 1초 | < 1초 | 5분 |
|          | 슈퍼컴 | < 1초 | 1초    | 1초 |


- 효율적인 알고리즘은 **슈퍼컴퓨터보다 더 큰 가치**가 있음
- 값 비싼 **하드웨어 개발**보다 **효율적인 알고리즘 개발**이 훨씬 더 경제적임

---

=> 파이썬에서 1초당 3000만번 정도 연산이 가능함 

pypy => 반복문 등의 연산은 빠름
python3 => 메모리 효율이 좋음

append() => 최대한 가능하다면 사용을 피하는 것이 좋음(메모리를 2배로 늘린 후 추가함) => 미리 리스트의 공간을 확보해놓고 인덱스에 값을 넣어주는 방식으로 하면 됨 


### 리스트에 10만 개 데이터 넣는 방법 비교

1. `append()`를 사용하는 방법

```python
li = []
for i in range(100_000):
    li.append()   # 데이터 입력 필요
```

* **특징**

  * `append()`를 이용해 리스트 끝에 하나씩 추가
  * 초기 크기가 정해져 있지 않음
  * 동적으로 리스트 크기가 늘어남
  * 입력 값이 많을 경우 메모리 사용량이 많아짐 


2.  미리 크기를 할당하는 방법

```python
li = [0] * 100_000
idx = 0
for i in range(100_000):
    li[idx] = input()
    idx += 1
```

* **특징**

  * 리스트 크기를 **고정된 크기(10만)** 로 미리 생성
  * 인덱스를 이용해 직접 값 할당
  * 메모리 공간을 미리 확보하기 때문에 경우에 따라 성능이 더 안정적

---

## 표준 입출력 방법
### 콘솔 입력 대신, 파일 입력으로 입력을 받기
1. 하나의 파일을 만들기 : input.txt
2. input.txt에는 내용을 적고 저장
3. main.py에는 
```python
import sys
sys.stdin = open("input.txt", "r")
```
와 같이 코드를 작성함

=> input()을 하더라도 사용자로부터 입력 받지 않고 텍스트 파일로부터 값을 가져옴

* 이점
- 시스템 상 복사의 문제점을 발견할 수 있음
- 여러가지 TC를 만들면서 테스트를 할 수 있음
- 디버깅할 떄도 TC와 output을 보면서 할 수 있음

---


