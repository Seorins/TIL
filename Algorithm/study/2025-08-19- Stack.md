## 부분집합(Powerset)
- 어떤 집합의 공집합과 자기자신을 포함한 모든 부분
- 구하고자 하는 어떤 집합의 원소 개수가 n일 경우 부분집합의 수는 2^n개임

### Backtracking 기법으로 powerset 만들기
- 앞에서 설명한 일반적인 Backtracking 접근 방법을 이용
- N개의 원소가 들어있는 집합의 2^n개의 부분집합을 |
- True 또는 False값을 가지는 항목들로 구성된 n개의 배열을 만드는 방법을 이용
- 여기서 배열의 i번째 항목은 i번째의 원소가 부분집합의 값인지 아닌지를 나타내는 값

### 부분 집합을 만드는 3가지 방법
1. 단순 반복 / 비트마스크
- 원소 포함 여부를 0과 1로 표현(bit array)

```python
arr = [1, 2, 3]
n = len(arr)

for mask in range(1 << n):  # 0 ~ 2^n - 1
    subset = []
    for i in range(n):
        if mask & (1 << i):   # i번째 비트가 1이면 포함
            subset.append(arr[i])
    print(subset)
```

2. 중첩 반복문 
- 직관적이지만 n이 크면 코드가 길어짐

```python 
bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1] = j
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l
                print(bit)

```

3. 백트래킹(backtracking)
- 재귀적으로 "현재 원소를 넣을까/말까" 두 가지 경우를 탐색
- 트리 구조로 확장되며 모든 경우(=부분집합)를 탐색

```python
arr = [1, 2, 3]
n = len(arr)
subset = [0] * n   # 포함 여부 저장

def backtrack(k):
    if k == n:  # 종료 조건
        print([arr[i] for i in range(n) if subset[i]])
    else:
        # k번째 원소를 포함
        subset[k] = 1
        backtrack(k+1)
        # k번째 원소를 포함하지 않음
        subset[k] = 0
        backtrack(k+1)

backtrack(0)
```

---

## 순열
### 단순하게 순열을 생성하는 방법
- 동일한 숫자가 포함되지 않았을 때, 각 자리 수 별로 loop을 이용해 표현할 수 있음

---

### 가지치기
### 부분집합의 합
- I원소의 포함 여부를 결정하면 i까지의 부분집합의 합 Si를 결정할 수 있음
- Si-1이 찾고자 하는 부분집합의 합보다 크면 남은 원소를 고려할 필요가 없음
- A[i]원소를 부분집합의 원소로 고려한느 재귀 함수 (A는 서로 다른 자연수의 집합)


---

## 분할정복 
- 큰 문제를 작은 문제로 쪼개서 풀고, 다시 합쳐서 전체 문제를 해결하는 방식
1. Divide(분할)
 -> 문제를 더 작은 하위 문제로 나눔
2. Conquer(정복)
 -> 나눠진 하위 문제를 재귀적으로 해결
3. Combine(결합)
 -> 하위 문제의 해답을 합쳐서 전체 해답을 만듦

ex) 이진 탐색 (Binary Search), 병합 정렬 (Merge Sort), 퀵 정렬 (Quick Sort)

### 백트래킹 vs 분할 정복
- 백트래킹 -> 모든 경우를 탐색하면서 조건 안 맞으면 return(가지치기) 
=> 탐색 + 가지치기
- 분할정복 -> 문제를 잘게 쪼개서 작은 문제 풀고, 합쳐서 큰 문제 해결
=> 문제 쪼개기 + 합치기

### 분할 정복 방법 (Exponentiation by Squaring, O(log n))
- 시간 복잡도: O(log n)
(한 번 계산할 때마다 지수가 절반으로 줄어들기 때문)