# Javascript
## Basic syntax
### Object (객체)
- 키로 구분된 데이터 집합을 저장하는 자료형(data collection)


---


## 구조 및 속성
### 겍체 구조
- 중괄호 ('{}')를 이용해 작성
- 중괄호 안에는 key:value 쌍으로 구성된 속성(property)를 여러 개 작성 가능
- key는 문자형만 허용
- value는 모든 자료형 허용

```js
const user = {
    name: 'Alice', 
    'key with space': true, 
    greeting: function(){
        return 'hello'
    }
} 
```


### 속성 참조
- 점('.') 표기법 또는 대괄호('[]') 표기법으로 객체 속성에 접근
- key 이름에 띄어쓰기 같은 구분자가 있으면 대괄호 접근만 가능

```js
// 조회
console.log(user.name) // Alice
console.log(user['key with space']) // true

// 추가
user.address = 'korea'
console.log(user) // {name: 'Alice', key woth space: true, address: 'korea', greeting: f}

// 수정
user.name = 'Bella'
cosole.log(user.name) // Bella

// 삭제 
delete user.name
console.log(user) // {key with space: true, address: 'korea', greeting: f}
```


### 'in' 연산자
- 속성이 객체에 존재하는지 여부를 확인
- 객체의 키나 배열의 인덱스 존재 여부를 확인하는 연산자
```js
console.log('greeting' in user) // true
console.log('country' in user) // false
```

* 객체에서 값의 포함 여부를 확인하려면 'in' 연산자 대신 'hasOwnProperty()' 메서드를 사용하는 것이 올바름
* 프로토타입 체인을 따라 상속된 속성까지 확인하므로, 의도치 않게 true가 나올 수 있어 주의 

* 프로토타입 
: 객체들이 기능을 물려받는 원본, 즉 부모 역할을 하는 객체
* 프로토타입 체인
: 자신에게 없는 속성이나 기능을 부모, 조상 순으로 찾아가는 것


---


## Method(메서드)
- 객체 속성에 정의된 함수
- object.method() 방식으로 호출
- 메서드는 객체가 **행동** 할 수 있게 함

```js
console.log(user.greeting()) // hello
```


### Method 기본 문법
- 메서드도 값이 함수인 속성

```js
const myObj2 = {
    numbers: [1, 2, 3], 
    myFunc: function(){
        this.numbers.forEach(function (number){
            console.log(this) // window
        })
    }
}

console.log(myObj2.myFunc())
```

- 메서드와 일반 함수의 차이는?
    - 메서드는 자신이 속한 객체의 다른 속성들에 접근할 수 있음
    - 이를 위한 방법이 this


---


## this
### 'this' keyword(1)
`Method`
- 객체 속성에 정의된 함수
- **this** 키워드를 사용해 객체 자신의 속성이나 메서드를 접근하여 특정 작업을 수행할 수 있음 


### 'this' keyword(2)
`this`
- 함수나 메서드를 호출한 객체를 가리키는 키워드
-> **this** 키워드를 사용해 객체에 대한 특정한 작업을 수행할 수 있음


### Method & this 사용 예시
```js
<!-- this-keyword.html -->

const person = {
    name: 'Alice'
    greeting: function(){
        return `Hello my name is ${this.name}`
    },
}

console.log(person.greeting()) // Hello my name is Alice
```


### JavaScript에서 this는 함수를 "호출하는 방법"에 따라 가리키는 대상이 달라짐

| 호출 방법                     | 대상                   |
|-------------------------------|-------------------------|
| 일반 함수에서의 단순 호출     | 전역 객체              |
| 객체에서의 메서드 호출        | 메서드를 호출한 객체   |



### 단순 호출 this

- 가리키는 대상 ⇒ **전역 객체**

```js
<!-- this-keyword.html -->

const myFunc = function () {
  return this
}

console.log(myFunc())  // window
```


### 메서드 호출 시 this

* 가리키는 대상 ⇒ **메서드를 호출한 객체**

```js
<!-- this-keyword.html -->

const myObj = {
  data: 1,
  myFunc: function () {
    return this
  }
}

console.log(myObj.myFunc())  // myObj
```


### 중첩된 함수에서의 this 문제점
- forEach의 인자로 전달된 콜백 함수는 일반 함수로 호출되므로, this는 전역 객체를 가리킴 

```js
const myObj2 = {
  numbers: [1, 2, 3],
  myFunc: function () {
    this.numbers.forEach(function (number) {
      console.log(this)  // window
    })
  }
}

console.log(myObj2.myFunc())
```


### 중첩된 함수에서의 this 문제점
- `forEach`의 인자로 작성된 **일반 함수**는  
  **일반 함수 호출 방식**이므로 `this`가 전역 객체(window)를 가리킴

```js
const myObj2 = {
  numbers: [1, 2, 3],
  myFunc: function () {
    this.numbers.forEach(function (number) {
      console.log(this)   // window
    })
  }
}

console.log(myObj2.myFunc())
```

---

### 해결책: 화살표 함수 사용

- **화살표 함수는 자신만의 this를 가지지 않음**
- 따라서 상위 스코프(여기서는 myFunc)의 this 값을 그대로 사용함 → `myObj3`

```js
const myObj3 = {
  numbers: [1, 2, 3],
  myFunc: function () {
    this.numbers.forEach((number) => {
      console.log(this)   // myObj3
    })
  }
}

console.log(myObj3.myFunc())
```


### JavaScript 'this' 정리
- JavaScript의 함수는 호출될 때 this를 암묵적으로 전달 받음
- JavaScript에서 this는 함수가 **호출되는 방식**에 따라 결정되는 현재 객체를 나타냄
- Python의 self와 Java의 this가 선언 시점에 이미 값이 정해지는 것과 달리 JavaScript의 this는 **함수가 호출될 때 동적으로 결정**

* 장점
    - 함수(메서드)를 하나만 만들어 여러 객체가 공유하여 각자 자신의 데이터로 동작하게 할 수 있음

* 단점
    - 이런 유연함이 실수로 이어질 수 있다는 것

* 개발자는 this의 동작 방식을 충분히 이해하고 장점을 취하면서 실수를 피하는 데 집중 
* this가 헷갈릴 땐 '누가 점(.)을 찍어 호출했는가?'에 집중. 점 앞의 객체가 this가 됨


---


## 추가 객체 문법
1. 단축 속성
2. 단축 메서드
3. 계산된 속성(computed property name)
4. 구조 분해 할당(destructing assignment)
5. 객체와 전개 구문(Spread Syntax)
6. Object keys() / values() / entries()
7. Optional chaining('?.')


---


## 객체 리터럴의 단축 문법

### 1. 단축 속성 (Shorthand Property)
- 키 이름과 값으로 쓰이는 **변수의 이름이 같을 때** 단축 구문 사용 가능

- 기존 방식
```js
const name = 'Alice'
const age = 30

const user = {
  name: name,
  age: age,
}
```

- 단축 속성 사용

```js
const name = 'Alice'
const age = 30

const user = {
  name,
  age,
}
```

---

### 2. 단축 메서드 (Shorthand Method)
- 객체의 메서드를 정의할 때 **function 키워드 생략 가능**

- 기존 방식

```js
const myObj1 = {
  myFunc: function () {
    return 'Hello'
  }
}
```

- 단축 메서드 사용

```js
const myObj1 = {
  myFunc() {
    return 'Hello'
  }
}
```

---

### 3. 계산된 속성 (computed property name)

- **키를 대괄호(`[]`)로 둘러싸서** 동적으로 생성하는 속성
- **고정된 값이 아닌 변수 값을 키로 사용할 수 있음**

```js
const product = prompt('물건 이름을 입력해주세요')
const prefix = 'my'
const suffix = 'property'

const bag = {
  [product]: 5,
  [prefix + suffix]: 'value',
}

console.log(bag)  
// 예: { 연필: 5, myproperty: 'value' }
```

* 대괄호 안의 표현식이 너무 복잡해지면
  **어떤 키가 생성되는지 파악하기 어려워 가독성이 떨어질 수 있음**
* 동적으로 키를 만들다 보면
  **의도치 않게 같은 이름의 키가 생성되어 기존 값이 덮어씌워질 위험**이 있음

---

### 4. 구조 분해 할당 (destructuring assignment) (1/2)
- 배열 또는 객체를 분해하여 **객체 속성을 변수로 쉽게 할당**할 수 있는 문법

- 기존 방식
```js
const userInfo = {
  firstName: 'Alice',
  userId: 'alice123',
  email: 'alice123@gmail.com'
}

const firstName = userInfo.firstName
const userId = userInfo.userId
const email = userInfo.email
```

- 구조 분해 할당 사용

```js
const userInfo = {
  firstName: 'Alice',
  userId: 'alice123',
  email: 'alice123@gmail.com'
}

// 필요한 속성만 꺼내기
const { firstName } = userInfo

// 여러 속성 꺼내기
const { firstName, userId } = userInfo

// 모두 꺼내기
const { firstName, userId, email } = userInfo

console.log(firstName, userId, email)
// Alice alice123 alice123@gmail.com
```


### 4. 구조 분해 할당 (destructuring assignment) (2/2)
- 함수의 매개변수에서도 객체 구조 분해 할당을 사용 가능

```js
const person = {
  name: 'Bob',
  age: 35,
  city: 'London',
}

function printInfo({ name, age, city }) {
  console.log(`이름: ${name}, 나이: ${age}, 도시: ${city}`)
}

// 객체를 넘기면 함수 매개변수에서 바로 분해하여 사용 가능
printInfo(person)
// 출력: 이름: Bob, 나이: 35, 도시: London
```

---

### 5. 객체와 전개 구문 (Spread Syntax, `...`)

- 객체 복사
    - 전개 구문(`...`)을 사용하면 **객체 내부의 속성을 전개하여 새로운 객체를 만들 수 있음**

- 얕은 복사에 활용 가능
* 얕은 복사란?  
: **겉(최상위 속성)만 복사하고, 중첩된 객체는 공유하는 복사 방식**

```js
const obj = { b: 2, c: 3, d: 4 }

const newObj = { a: 1, ...obj, e: 5 }

console.log(newObj)
// { a: 1, b: 2, c: 3, d: 4, e: 5 }
```

---

### 6. 유용한 객체 메서드

- Object.keys()
    - Object의 **key 값들**을 리스트로 반환

- Object.values()
    - Object의 **value 값들**을 리스트로 반환

- Object.entries()
    - Object의 **key와 value 쌍**을 한 쌍으로 묶은 리스트로 반환

```js
const profile = {
  name: 'Alice',
  age: 30,
}

// ['name', 'age']
console.log(Object.keys(profile))

// ['Alice', 30]
console.log(Object.values(profile))

// [['name', 'Alice'], ['age', 30]]
console.log(Object.entries(profile))
```

---

### 7. Optional chaining (`?.`)

- **속성이 없는 중첩 객체에 접근할 때** 에러 없이 안전하게 접근하는 방법  
- 참조 대상이 `null` 또는 `undefined`라면 에러 대신 **평가를 중단하고 `undefined` 반환**

```js
const user = {
  name: 'Alice',
  greeting: function () {
    return 'hello'
  }
}

// Uncaught TypeError
console.log(user.address.street)

// undefined
console.log(user.address?.street)

// Uncaught TypeError
console.log(user.nonMethod())

// undefined
console.log(user.nonMethod?.())
```


### 7. Optional chaining (`?.`) 장점

- **참조가 누락될 가능성이 있는 경우**, 연결된 속성으로 접근할 때 더 **짧고 간단한 표현식**을 작성할 수 있음
- 어떤 속성이 필요한지 확실하지 않을 때 객체 내용을 **더 편리하게 탐색**할 수 있음
- Optional chaining을 사용하지 않는다면 아래처럼 `&&` 연산자를 사용해야 함

```js
const user = {
  name: 'Alice',
  greeting: function () {
    return 'hello'
  }
}

console.log(user.address && user.address.street)  
// undefined
```


### 7. Optional chaining (`?.`) 주의사항

1. Optional chaining은 존재하지 않아도 괜찮은 대상에만 사용해야 함 (남용 금지)
    - **왼쪽 평가 대상이 없어도 괜찮은 경우**에만 선택적으로 사용
    - 목적: 중첩 객체를 에러 없이 접근하기 위함

```js
// Bad ❌
user.address?.street  // address는 필수 속성이 아님

// Good ⭕
user.address?.street
```

2. Optional chaining 앞의 변수는 반드시 선언되어 있어야 함

```js
console.log(myObj?.address)  
// Uncaught ReferenceError: myObj is not defined
```


### 7. Optional chaining (`?.`) 정리

1. `obj?.prop`
    - `obj`가 **존재하면** `obj.prop`을 반환하고  
    - 존재하지 않으면 `undefined`를 반환

2. `obj?.[prop]`
    - `obj`가 **존재하면** `obj[prop]`을 반환하고  
    - 존재하지 않으면 `undefined`를 반환

3. `obj?.method()`
    - `obj`가 **존재하면** `obj.method()`를 호출하고  
    - 존재하지 않으면 `undefined`를 반환

* Optional chaining은 **null과 undefined일 때만 동작**
* 체인 중간이 null일 경우, 이후 코드는 실행되지 않음.
  이를 **단락 평가(short-circuit evaluation)** 라고 부름


---


## JSON(JavaScript Object Notation)
- Key-Value 형태로 이루어진 자료 표기법
- JavaScript의 Object와 유사한 구조를 가지고 있지만 JSON은 일정한 형식을 가진 **문자열**
- JavaScript에서 JSON을 사용하기 위해서는 Object 자료형으로 변경해야 함
- 특정 언어에 종속되지 않는 데이터 형식으로, API 통신 등에서 널리 사용됨


### Object ⇒ JSON
- `JSON.stringify()` 를 사용해 **객체를 문자열로 변환**

```js
const jsObject = {
  coffee: 'Americano',
  iceCream: 'Cookie and cream',
}

// Object → JSON
const objToJson = JSON.stringify(jsObject)

console.log(objToJson)
// {"coffee":"Americano","iceCream":"Cookie and cream"}

console.log(typeof objToJson)
// string
```

### JSON ⇒ Object

* `JSON.parse()` 를 사용해 **문자열을 객체로 변환**

```js
// JSON → Object
const jsonToObj = JSON.parse(objToJson)

console.log(jsonToObj)
// { coffee: 'Americano', iceCream: 'Cookie and cream' }

console.log(typeof jsonToObj)
// object
```

---


## Array(배열)
- 순서가 잇는 데이터 집합을 저장하는 자료 구조
- 객체는 키(key)로 데이터를 관리 하지만, 순서가 중요하지 않음
- '첫 번째', '두 번째'처럼 순서가 중요한 데이터 묶음이 필요할 때 사용하는 것이 바로 **순서가 있는 컬렉션, 배열(Array)**
- 하지만 배열의 인덱스는 숫자로만 이루어져 있어 **키 자체가 데이터의 의미를 설명해주지 못하고** 특정 값을 찾기 위해서는 배열의 모든 요소를 **처음부터 순서대로 확인**해야 하는 단점이 있음


### 배열 구조

- 대괄호(`[]`)를 이용해 작성
- 요소의 자료형에는 제약 없음
- `length` 속성을 사용해 배열에 담긴 요소 개수 확인 가능

```js
const names = ['Alice', 'Bella', 'Cathy']

console.log(names[0]) // Alice
console.log(names[1]) // Bella
console.log(names[2]) // Cathy

console.log(names.length) // 3
```


---


## 배열 메서드
- push()
- pop()
- unshift()
- shift()


### push()
- 배열 **끝에 요소 추가**
- 원본 배열을 **직접 수정**
- 반환 값: **추가된 후의 새로운 배열 길이**

```js
const names = ['Alice', 'Bella', 'Cathy']

names.push('Dan')

// ['Alice', 'Bella', 'Cathy', 'Dan']
console.log(names)
```


### pop()

* 배열 **끝의 요소 제거**
* 원본 배열을 **직접 수정**
* 반환 값: **제거된 요소**

```js
const names = ['Alice', 'Bella', 'Cathy']

console.log(names.pop()) // Dan

// ['Alice', 'Bella', 'Cathy']
console.log(names)
```


### unshift()
- 배열 **앞에 요소를 추가**
- 원본 배열을 **직접 수정**
- 반환 값: **추가된 후의 새로운 배열 길이**
- 배열의 모든 요소를 뒤로 한 칸씩 밀어야 하므로  
  **배열이 클수록 성능이 저하됨 (가급적 사용 X)**

```js
names.unshift('Eric')

// ['Eric', 'Alice', 'Bella', 'Cathy']
console.log(names)
```


### shift()

* 배열 **앞 요소를 제거**하고, 제거된 요소를 반환
* 원본 배열을 **직접 수정**
* 반환 값: **제거된 요소**
* 배열의 모든 요소를 앞으로 당겨야 하므로
  **배열이 클수록 성능이 저하됨 (가급적 사용 X)**

```js
console.log(names.shift()) // Eric

// ['Alice', 'Bella', 'Cathy']
console.log(names)
```


---


## Array helper method
- 배열 조작을 보다 쉽게 수행할 수 있는 특별한 메서드 모음
- ES5에 도입
- 배열의 각 요소를 **순회**하며 각 요소에 대해 함수(**콜백함수**)를 호출
- 대표 메서드
    - forEach(), map()
    - filter()
    - every()
    - some()
    - reduce()
    - 등등
- 메서드 호출 시 인자로 함수(**콜백함수**)를 받는 것이 특징


---


## Callback function(콜백 함수)
- 다른 함수에 인자로 전달되는 함수
- 외부 함수 내에서 호출되어 일종의 루틴이나 특정 작업을 진행
- 특정 작업(1초 기다리기, ...)이 완료된 후, 시스템에 의해 나중에 호출(call back)되는 함수


### 콜백 함수 예시 1

```js
const numbers1 = [1, 2, 3]

numbers1.forEach(
  function (num) {
    console.log(num)
  }
)

// 1
// 2
// 3
```

### 콜백 함수 예시 2

```js
const numbers2 = [1, 2, 3]

const callBackFunction = function (num) {
  console.log(num)
}

numbers2.forEach(callBackFunction)

// 1
// 2
// 3
```


### 주요 Array Helper Methods
- forEach
    - 배열 내의 모든 요소 각각에 대해 함수(콜백함수)를 호출
    - 반환 값 없음

- map
    - 배열 내의 모든 요소 각각에 대해 함수(콜백함수)를 호출
    - 함수 호출 결과를 모아 새로운 배열을 반환


---


## forEach()
- 배열의 각 요소를 반복하며 모든 요소에 대해 함수(콜백함수)를 호출
- 구조
```js
// forEach 구문
arr.forEach(callback(item[, index[, array]]))
```

```js
// forEach 예
array.forEach(function(item, index, array){
    // do something
})
```

- 콜백함수는 3가지 매개변수로 구성
    - item : 처리할 배열의 요소
    - inedx : 처리할 배열 요소의 인덱스(선택 인자)
    - array : forEach를 호출한 배열(선택 인자)

- 반환 값
    - undefined


### forEach 예시

- 동일한 결과를 만들어 냄
- 간단한 콜백 함수의 경우, **화살표 함수**를 사용하는 것이 가독성이 좋고  
  `this`를 다루는 방식의 차이 때문에 **가능한 화살표 함수 사용 권장**

```js
// 실행 코드
const names = ['Alice', 'Bella', 'Cathy']

// 일반 함수 표기
names.forEach(function (name) {
  console.log(name)
})

// 화살표 함수 표기
names.forEach((name) => {
  console.log(name)
})
```

```js
// 출력 결과
Alice
Bella
Cathy

Alice
Bella
Cathy
```


### forEach 활용

- `forEach`는 **항상 undefined를 반환**
- `break` 문으로 반복을 중단할 수 없음  
  (※ 반복 중단하는 방법은 이후 “참고”에서 설명)
- 간결한 코드를 위해 필요한 매개변수만 활용하면 됨

```js
// 실행 코드
const names = ['Alice', 'Bella', 'Cathy']

names.forEach((name, index, array) => {
  console.log(`${name} / ${index} / ${array}`)
})
```

```js
// 출력 결과
Alice / 0 / Alice,Bella,Cathy
Bella / 1 / Alice,Bella,Cathy
Cathy / 2 / Alice,Bella,Cathy
```

