# Javascript
## Basic syntax
### 데이터 타입 
- 원시 자료형(Primitive type)
    - 값(value) 자체가 변수에 직접 저장되는 자료형
    - 불변(immutable)이며, 변수 간 할당 시 값이 복사
    - Numver, String, Boolean, null, undefined

- 참조 자료형(Reference type)
    - 데이터가 저장된 메모리의 주소가 변수에 저장되는 자료형
    - 가변(Mutable)이며, 변수 간 할당 시 주소가 복사
    - Objects(Object, Array, Function)

* 참조 자료형은 주소를 복사하므로, 복사본을 수정하면 원본의 값도 함께 변경될 수 있어 주의해야 함
* 값이 불변이라는 것은, 값의 일부를 직접 수정할 수 없다는 의미 
(len str = 'apple'; str[0] = 'A';)처럼 할당하는 것은 불가능


### 원시 자료형 예시
- 변수에 할당될 때 값이 복사됨
-> 변수 간에 서로 영향을 미치지 않음

```JS
const a = 'bar'
console.log(a) // bar

a.toUpperCase()
console.log(a) // bar
```

```js
let a = 10
let b = a

b = 20

console.log(a) // 10
console.log(b) // 20 
```


### 참조 자료형 예시
- 객체를 생성하면 객체의 메모리 주소를 변수에 할당
-> 변수 간에 서로 영향을 미침

```js
const obj1 = {name: 'Alice', age: 30}
const obj2 = obj1

obj2.age = 40

console.log(obj1.age) // 40
console.log(obj2.age) // 40
```


---


## 원시 자료형 
### 원시 자료형 종류
- Number
- String
- null
- undefined
- Boolean


### 원시 자료형 - Number
- 정수 또는 실수형 숫자를 표현하는 자료형
- 사칙 연산 및 나머지 연산 가능
- 문자열과 + 연산 시, 숫자가 문자열로 자동 형 변환되어 연결
- 정수와 실수 구분이 없고, 모든 숫자를 단일 타입으로 처리 \


### 원시 자료형 - String
- 텍스트 데이터를 표현하는 자료형
- '+' 연산자를 사용해 문자열끼리 결합
- 뺄셈, 곱셈, 나눗셈 불가능 


### Template literals (템플릿 리터럴)
- 내장된 표현식을 허용하는 향상된 문자열 작성 방식
- Backtick(``)을 이용하며, 여러 줄에 걸쳐 문자열을 정의할 수도 있고 JavaScript의 변수를 문자열 안에 바로 연결할 수 있음
- 표현식은 '$'와 ㅡ중괄호 ({expression})로 표기
- ES6+부터 지원

```JS
cosnt age = 100
const message = `홍길동은 ${age}세입니다.`
```


### null
- 프로그래머가 의도적으로 **값이 없음**을 나타낼 때 사용


### undefined
- 시스템이나 JavaScript 엔진이 **값이 할당되지 않음**을 나타낼 때 사용

* null 타입은 'object', undefined의 타입은 'undefined'이므로 타입 검사 시 주의
* return이 없는 함수나, 인자가 전달되지 않은 매개변수는 기본적으로 undefined가 할당됨 
* 산술 연살 시 null은 0으로 취급되지만 undefined는 계산 불가능한 NaN 값을 만듦


### 원시 자료형 - Boolean
- 참과 거짓을 나타내는 논리적인 자료형
- 조건문 또는 반복문에서 Boolean이 아닌 데이터 타입은 **자동 형변환 규칙**에 따라 true 또는 false로 변환됨


### 자동 형변환 

| 데이터 타입  | false                           | true         |
|--------------|----------------------------------|--------------|
| undefined    | 항상 false                      | X            |
| null         | 항상 false                      | X            |
| Number       | 0, -0, NaN                       | 나머지 모든 경우 |
| String       | '' (빈 문자열)                  | 나머지 모든 경우 |


---


## 연산자
### 연산자 종류
- 할당 연산자
- 증가 & 감소 연산자
- 비교 연산자
- 동등 연산자
- 일치 연산자
- 논리 연산자 


### 할당 연산자
- 오른쪽에 있는 피연산자의 평가 결과를 왼쪽 피연산자에 팔당하는 연산자
- **단축 연산자** 지원

* 단축 연산자 
: x = x + 1을 x += 1 처럼 코드를 짧게 줄여주는 연산자 


### 증가 & 감소 연산자
- 증가 연산자 ('++')
    - 피연산자를 증가(1을 더함)시키고 연산자의 위치에 따라 증가하기 전이나 후의 값을 반환
- 감소 연산자 ('--')
    - 피연산자를 감소(1을 뻼)시키고 연산자의 위치에 따라 감소하기 전이나 후의 값을 반환

=> 코드의 가독성을 위해 a += 1, a -= 1과 같이 더 명시적인 표현을 권장 


### 비교 연산자
- 피연산자들(숫자, 문자, Boolean 등)을 비교하고 결과 값을 boolean으로 반환하는 연산자 

```js
3 > 2 // true
3 < 2 // false

'A' < 'B' // true
'Z' < 'a' // ture
'가' < '나' // true 
```


### 동등 연산자(==)
- 두 연산자가 같은 값으로 평가되는지 비교한 후 boolean 값을 반환
- '암묵적 타입 변환' 통해 타입을 일치시킨 후 같은 값인지 비교
- 두 피연산자가 모두 객체일 경우 메모리의 같은 객체를 바라보는지 판별

```js
console.log(1 == 1); // true
console.log('hello' == 'hello'); // true
console.log('1' == 1); // true
console.log(0 == false); // true
```

* 0 == false, '' == [] 가 true가 되는 등, 직관과 다른 암묵적 타입 변환이 일어나니 주의 
* 내용과 같아도 다른 객체이면 false. [1] == [1]은 false이니 주의


### 일치 연산자(===)
- 두 피연산자의 값과 타입이 모두 같은 경우 true를 반환
- 같은 객체를 가리키거나, 같은 타입이면서 같은 값인지를 비교
- 엄격한 비교가 이뤄지며 암묵적 타입 변환이 발생하지 않음
- 특별한 경우를 제외하고는, 예측하지 못한 결과를 방지하기 위해 **일치 연산자(===) 사용을 권장**

```js
console.log(1 === 1); // true
console.log('hello' === 'hello'); // true
console.log('1' === 1); // false
console.log(0 === false); // false
```


### 논리 연산자
- and 연산
    - &&
- or 연산
    - ||
- not 연산 
    - |
- 단축 평가 지원 

```js
true && false // false
true && true  // true

false || true // true
false || false // false

!true // false

1 && 0 // 0
0 && 1 // 0
4 && 7 // 7
1 || 0 // 1
0 || 1 // 1
4 || 7 // 4

```


---


## 조건문 
### if
- 조건 표현식의 결과값을 boolean 타입으로 변환 후 참/거짓을 판단

```js
const name = 'customer';

if (name === 'admin') {
    console.log('관리자님 환영해요');
} else if (name === 'customer') {
    console.log('고객님 환영해요');
} else {
    console.log(`반갑습니다. ${name}님`);
}

```


### 삼항 연산자
- 간단한 조건부 로직을 간결하게 표현할 때 유용
- 복잡한 로직이나 대다수의 경우에는 가독성이 떨어질 수 있으므로 적절한 상황에서만 사용할 것
- condition
    - 평가할 조건 (true 또는 false로 평가)
- expression1
    - 조건이 true일 경우 반환할 값 또는 표현식
- expression2
    - 조건이 false일 경우 반환할 값 또는 표현식

```js
const age = 20;
const message = (age >= 18) ? '성인' : '미성년자';
console.log(message); // '성인'
```

* 삼항 연산자 표현식
`condition ? expression1 : expression2`


---


## 반복문 
### 반복문 종류
- while
- for
- for ... in
- for ... of 


### while 반복문
- 조건이 참이면 문장을 계속해서 수행 

```js
// while loop 기본 구조
while (조건문) {
    // do something
}

// 실제 코드 예시
let i = 0;
while (i < 6) {
    console.log(i);
    i += 1;
}
```


### for 반복문
- 특정한 조건이 거짓으로 판별될 때까지 반복

```js
// for loop 기본 구조
for ([초기문]; [조건문]; [증감문]) {
    // do something
}

// 실제 코드 예시
for (let i = 0; i < 6; i++) {
    console.log(i);
}
```


### for ... in
객체의 열거 가능한(eunumerable) 속성(property)의 **키(key)**에 대해 반복

```js
// for...in 기본 구조
for (variable in object) {
    statement
}

// 실제 코드 예시
const fruits = { a: 'apple', b: 'banana' };
for (const property in fruits) {
    console.log(property); // a, b
    console.log(fruits[property]); // apple, banana
}
```


---


## for ... of
- 반복 가능한(iterable) 객체(배열, 문자열 등)의 **값(value)**에 대해 반복 

```js
// for...of 기본 구조
for (variable of iterable) {
    statement
}

// 실제 코드 예시
const numbers = [0, 1, 2, 3];
for (const number of numbers) {
    console.log(number); // 0, 1, 2, 3
}
```


---


## for ... in 과 for ... of

1. **`for...in`을 사용한 배열 순회 (잘못된 예시)**:

   ```javascript
   // Array
   const arr = ['a', 'b', 'c'];
   for (const elem in arr) {
       console.log(elem); // 0 1 2
   }
   ```

   * `for...in`은 배열을 순회할 때 배열의 **인덱스**(0, 1, 2)를 반환합니다.

2. **`for...in`을 사용한 객체 순회**:

   ```javascript
   // Object
   const capitals = {
       korea: '서울',
       japan: '도쿄',
       china: '베이징',
   };
   for (const capital in capitals) {
       console.log(capital); // korea japan china
   }
   ```

   * `for...in`은 객체의 **속성 이름**을 순회합니다. 여기서는 `"korea"`, `"japan"`, `"china"`가 출력됩니다.

3. **`for...of`를 사용한 배열 순회 (올바른 예시)**:

   ```javascript
   // Array
   const arr = ['a', 'b', 'c'];
   for (const elem of arr) {
       console.log(elem); // a b c
   }
   ```

   * `for...of`는 배열의 **값**을 순회합니다. 배열 요소인 `"a"`, `"b"`, `"c"`가 출력됩니다.

4. **`for...of`를 사용한 객체 순회 (잘못된 예시)**:

   ```javascript
   // Object
   const capitals = {
       korea: '서울',
       japan: '도쿄',
       china: '베이징',
   };
   for (const capital of capitals) {
       console.log(capital); // TypeError: capitals is not iterable
   }
   ```

   * 객체는 이터러블 객체가 아니기 때문에, `for...of`를 사용하면 `TypeError: capitals is not iterable` 오류가 발생합니다.

### 핵심 포인트:

* **배열**에서는 `for...in`이 인덱스를 순회하고, `for...of`는 값을 순회합니다.
* **객체**에서는 `for...in`을 사용하여 속성 이름을 순회할 수 있지만, `for...of`는 사용할 수 없습니다.


### 배열 반복과 for ... in(1)
- 객체의 관점에서 보면, 배열의 인덱스도 **정수 형태의 이름을 가진 열거 가능한 속성**
- for ... in은 정수가 아닌 이름과 속성을 포함하여 열거 가능한 모든 속성을 반환
- 내부적으로 for ... in은 배열의 반복자가 아닌 속성 열거를 사용하기 때문에 특정 순서에 따라 인덱스를 반환하는 것을 보장할 수 없음

-> 따라서 for...in은 인덱스의 순서가 중요한 배열에서는 사용하지 않음
-> 배열에서는 **for 문, for ... of 를 사용**


### 배열 반복과 for ... in(2)
- 객체 관점에서 배열의 인덱스는 정수 이름을 가진 속성이기 때문에 인덱스가 출력됨(순서 보장 x)

```js
const arr = ['a', 'b', 'c'];

// for...in: 배열의 인덱스를 순회
for (const i in arr) {
    console.log(i); // 0, 1, 2
}

// for...of: 배열의 값을 순회
for (const i of arr) {
    console.log(i); // a, b, c
}
```

* for ... in 은 배열의 값이 아닌 인덱스를, 그것도 숫자가 아닌 '문자열'로 반환하니 주의해야 함
* 배열의 프로토타입에 추가된 속성까지 순회할 수 있어, 예기치 않은 버그를 유발할 수 있음


### 반복문 사용 시 const 사용 여부
- for 문
    - for (let i=0; i<arr.length; i++){...}의 경우에는 최초 정의한 i를 '재할당'하면서 사용하기 때문에 **const를 사용하면 에러 발생 **

```js
const arr = [1, 2, 3, 4, 5];

// `for` 문에서 `i`는 계속 재할당됨
for (let i = 0; i < arr.length; i++) {
    console.log(i);  // 0, 1, 2, 3, 4
}

// 아래와 같이 `const`를 사용하면 에러 발생
for (const i = 0; i < arr.length; i++) {
    console.log(i);  // Error: Assignment to constant variable.
}
```

- for ... in , for ... of
    - 재할당이 아니라, 매 반복마다 다른 속성 이름이 변수에 지정되는 것이므로 **const를 사용해도 에러가 발생하지 않음**

    - 단, const 특징에 따라 블록 내부에서 변수를 수정할 수 없음

```js
const obj = { a: 'apple', b: 'banana', c: 'cherry' };

// `for...in` 문에서는 객체의 속성 이름을 순회
for (const key in obj) {
    console.log(key);  // a, b, c
}
```

```js
const arr = ['apple', 'banana', 'cherry'];

// `for...of` 문에서는 배열의 값을 순회
for (const value of arr) {
    console.log(value);  // apple, banana, cherry
}

```


### 반복문 종합 
| 키워드            | 특징       | 스코프           |
|-------------------|------------|------------------|
| `while`           | -          | 블록 스코프      |
| `for`             | -          | 블록 스코프      |
| `for ... in`      | object 순회 | 블록 스코프      |
| `for ... of`      | iterable 순회 | 블록 스코프      |


---


## 함수
### Function
- 참조 자료형에 속하며 모든 함수는 Function object


### 함수 구조
```js
function name([param[, param, [..., param]]]) {
    statements
    return value
}
```

- function 키워드
- 함수의 이름
- 함수의 매개변수
- 함수의 body를 구성하는 statements
* return 문이 없거나 return 뒤에 값이 없으면, 함수는 undefined를 반환


### 함수의 정의 2가지 방법
### 1. 선언식(function declaration)
```js
funcion funcName(){
    statements
}
```

### 2. 표현식(function expression)
```js
const funcName = function(){
    statements
}
```


### 함수 선언식 특징
- 호이스팅 됨
- 코드의 구조와 가독성 면에서는 표현식에 비해 장점이 있음
```js
add(1, 2) // 3

function add (num1, num2){
    return num1 + num2
}
```

* 호이스팅
    - 자바스크립트 엔진이 코드 실행 전 변수와 함수 선언을 스코프 최상단으로 끌어올리는 동작 방식
    - 선언식으로 된 함수는 선언 전에 호출하는 것이 가능해짐 


### 함수 표현식 특징
- 호이스팅 되지 않음
    - 변수 선언만 호이스팅되고 함수 할당은 실행 시점에 이루어짐
- 함수 이름이 없는 **익명 함수**를 사용할 수 있음
```js
sub(2, 1) // ReferenceError: Cannot access 'sub' before initialization

const sub = function (num1, num2) {
    return num1 - num2
}
```

* 익명 함수
: 이름 없이, 필요할 때 즉시 만들어서 사용하는 일회용 함수 


### 함수 표현식 사용을 권장하는 이유
- 예측 가능성
    - 호이스팅의 영향을 받지 않아 코드 실행 흐름을 더 명확하게 예측할 수 있음
- 유연성
    - 변수에 할당되므로 함수를 값으로 다루기 쉬움
- 스코프 관리
    - 블록 스코프를 가지는 let이나 const와 함께 사용하여 더 엄격한 스코프 관리가 가능


---


## 매개변수 
### 매개변수 정의 바업
1. 기본 함수 매개 변수
2. 나머지 매개 변수

* 매개 변수
: 함수가외부로부터 값을 전달받기 위해 만들어 놓은 변수


### 1. 기본 함수 매개변수 (Defalut function parameter)
- 함수 호출 시 인자를 전달하지 않거나 undefined를 전달할 경우, 지정된 기본값으로 매개변수를 초기화

```js
const greeting = function (name = 'Anonymous') {
    return `Hi ${name}`
}

greeting()
```


### 2. 나머지 매개변수 (Rest parameter)
- 정해지지 않은 개수의 인자들을 배열로 모아서 받는 방법
- 작성 규칙
    - 함수 정의 시 나머지 매개변수는 하나만 작성할 수 있음
    - 나머지 매개변수는 함수 정의에서 매개변수 마지막에 위치해야 함


```js
const myFunc = function (param1, param2, ...restParams){
    return [param1, param2, restParams]
}

myFunc(1, 2, 3, 4, 5) // [1, 2, [3, 4, 5]]
myFunc(1, 2) // [1, 2, []]
```


### 매개변수와 인자 개수가 불일치할 때(1)
- 매개변수 개수 > 인자 개수 
-> 누락된 인자는 undefined로 할당

```js
const threeArgs = function (param1, param2, param3) {
    return [param1, param2, param3];
}

console.log(threeArgs());           // [undefined, undefined, undefined]
console.log(threeArgs(1));          // [1, undefined, undefined]
console.log(threeArgs(2, 3));       // [2, 3, undefined]
```


### 매개변수와 인자 개수가 불일치 할 때(2)
- 매개변수 개수 < 인자 개수
-> 초과 입력한 인자는 사용하지 않음

```js
const noArgs = function () {
    return 0;
}

console.log(noArgs(1, 2, 3)); // 0

const twoArgs = function (param1, param2) {
    return [param1, param2];
}

console.log(twoArgs(1, 2, 3)); // [1, 2]
```


---


## Spread syntax
### Spread syntax '...'
- 전개 구문
- 배열이나 문자열처럼 반복 가능한(iterable) 항목들을 개별 요소로 펼치는 것
- 전개 대상에 따라 역할이 다름
    -> 배열이나 객체의 요소를 개별적인 값으로 분리하거나 다른 배열이나 객체의 요소를 현재 배열이나 객체에 추가하는 등


### 전개 구문 활용처
1. 함수와의 사용
    1. 함수 호출 시 인자 확장
    2. 나머지 매개변수(압축)

2. 객체와의 사용
3. 배열과의 사용


### 전개 구문 활용(1)
- 함수와의 사용
    1. 인자 확장(함수 호출 시)

```JS
function myFunc(x, y, z) {
    return x + y + z;
}

let numbers = [1, 2, 3];

console.log(myFunc(...numbers)); // 6
```


### 전개 구문 활용(2)
- 함수와의 사용
    2. 나머지 매개변수(압축)

```JS
function myFunc2(x, y, ...restArgs) {
    return [x, y, restArgs];
}

console.log(myFunc2(1, 2, 3, 4, 5)); // [1, 2, [3, 4, 5]]
console.log(myFunc2(1, 2)); // [1, 2, []]
```


---


## 화살표 함수 표현식 (Arrow function expressiosn)
- 함수 표현식의 간결한 표현법

```js
const arrow = function(name){
    return `hello ${name}`
}
```

```js
const arrow = name => `hello ${name}`
```


### 화살표 함수 작성 과정
1. function 키워드 제거 후 매개변수와 중괄호 사이에 화살표 (=>) 작성
2. 함수의 매개변수가 하나 뿐이라면, 매개변수의 `()` 제거 가능
(단, 생략하지 않는 것을 권장)
3. 함수 본문의 표현식이 한 줄이라면, `{}`와 `return`제거 가능 

```js
const arrow1 = function (name) {
    return `hello, ${name}`
}

// 1. function 키워드 삭제 후 화살표 작성
const arrow2 = (name) => {return `hello, ${name}`}

// 2. 인자의 소괄호 삭제 (인자가 1개일 경우에만 가능)
const arrow3 = name => {return `hello, ${name}`}

// 3. 중괄호와 return 삭제 (함수 본문이 return을 포함한 표현식 1개일 경우에만 가능)
const arrow4 = name => `hello, ${name}`
```


---


## 참고 
### NaN
### NaN을 반환하는 경우 예시
1. 숫자로서 읽을 수 없음 (Number(undefined))
2. 결과가 허수인 수학 계산식 (Math.sqrt(-1))
3. 피연산자가 NaN (7 ** NaN)
4. 정의할 수 없는 계산식 (0 * Infinity)
5. 문자열을 포함하면서 덧셈이 아닌 계산식 ('가' / 3)

* NaN은 자기 자신과 비교해도 False가 나오는 유일한 값 (NaN === NaN // False)
* NaN은 '숫자가 아님'이라는 뜻이지만, 타입을 확인하면 'number'가 반환됨


---


## null & undefined
### '값이 없음'에 대한 표현이 null과 undefined 2가지인 이유
1. 역사적 맥락
    - JavaScript가 처음 만들어질 때, null은 '객체가 없음'을 나타내기 위한 도입
    - undefined는 나중에 추가되어 '값이 할당되지 않음'을 나타내게 됨

2. typeof null의 결과가 'object'인 이유 (역사적 배경)
    - 초기 버전에서 값의 타입을 나타내는 32비트 시스템을 사용
    - 타입 태그로 하위 3비트를 사용했는데, '000'은 객체를 나타냄
    - null은 모든 비트가 0인 특별한 값(Null 포인터)으로 표현되었는데, 하필 객체 타입을 나타내는 태그 또한 000이었기 때문에 null을 객체로 잘못 판별하게 됨

    ```js
    typeof null // 'object'
    typeof undefined // 'undefined'
    ```

3. ECMAScript의 표준화
    - ECMAScript 명서에서는 null을 원시 자료형으로 정의
    - 그러나 typeof null의 결과는 역사적인 이유로 'object' 유지
    - ECMAScript 5 개발 중 이 문제를 수정하려는 시도가 있었지만, 이미 typeof null === 'object'라는 전제하에 만들어진 수많은 웹 사이트와의 하위 호환성 문제 때문에 수정되지 못함

    ```js
    typeof null // 'object'
    typeof undefined // 'undefined'

    null == undefined // true
    null === undefined // false
    ```


---


## 화살표 함수 심화

```js
// 1. 인자가 없다면 () or _ 로 표시 가능
const noArgs1 = () => 'No args';
const noArgs2 = _ => 'No args';

// 2-1. object를 return 한다면 return을 명시적으로 작성해야 함
const returnObject1 = () => { return { key: 'value' } };

// 2-2. return을 작성하지 않으려면 객체를 소괄호로 감싸야 함
const returnObject2 = () => ({ key: 'value' });
```