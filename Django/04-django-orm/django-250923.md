# Django
## ORM(Object-Relational-Mapping)
- 객체 지향 프로그래밍 언어의 객체와 데이터베이스의 데이터를 매핑하는 기술
- 개발자 친화적인 데이터베이스 인터페이스 

### 문제 상황 : 언어 차이로 인한 소통 불가
- Django는 Python 언어를 사용하지만 데이터배이스는 SQL 언어를 사용함

### ORM의 역할 : 번역자 역할
- ORM은 Django와 데이터베이스 사이에서 언어 번역자 역할을 수행

### Django의 데이터 상호작용 : ORM이 일하는 방법
- ORM은 Django 개발자를 위해 'QuerySet API'라는 특별한 도구를 제공함
  - QuerySet API는 ORM의 기능을 개발자가 Python 코드 안에서 객체 지향적이고 직관적인 방식으로 데이터베이스를 조작할 수 있도록 제공하는 인터페이스

---

## QuerySet API
- 데이터베이스의 복잡한 SQL 쿼리문을 직관적인 Python 코드로 다룰 수 있게 해주는 강력한 번역기 
- 개발자는 SQL을 직접 작성하지 않고도 .filter(), exclude(), .order_by() 등 파이썬다운 메스드를 사용하여 원하는 데이터를 손쉽게 생성, 조회, 수정, 삭제할 수 있음
- 코드의 가독성을 높이고 개발 생산성을 극대화하는 Django ORM의 핵심 기능

### QuerySet API와 ORM의 동작 방식
1. Django -> DB : Django(QuerySet API)에서 ORM을 통해 데이터베이스로 정보를 요청할 떄 
  - SQL 쿼리로 변환되어 데이터베이스로 전달됨

2. DB -> Django : 데이터베이스가 요청에 대한 응답을 보낼 때
  - ORM은 이 SQL 결과를 다시 파이썬이 이해할 수 있는 Python Object
  - QuerySet 또는 Instance 형태로 변환하여 Django로 반환


### QuerySet API 구문 기본 구조

`Article.objects.all()`

### 1. Article (모델 클래스)

* 역할: 데이터베이스 테이블에 대한 **Python 클래스 표현**
* 예시: `articles_article` 테이블의 스키마(필드, 데이터 타입 등)를 정의
* Django ORM이 데이터베이스와 상호작용할 때 사용하는 기본 구조체

### 2. .objects (매니저, Manager)

* 역할: 데이터베이스 조회(Query) 작업을 위한 기본 인터페이스
* 모델 클래스가 데이터베이스 쿼리 작업을 수행할 수 있도록 하는 진입점
* Django는 모든 모델에 `objects`라는 이름의 매니저를 자동으로 추가
* 이 매니저를 통해 `.all()`, `.filter()` 등 쿼리 메서드를 호출할 수 있음

### 3. .all() (QuerySet API 메서드)

* 역할: 특정 데이터베이스 작업을 수행하는 명령
* 매니저를 통해 호출되는 메서드로, 해당 모델과 연결된 테이블의 **모든 레코드(rows)** 를 조회하는 SQL 쿼리를 생성하고 실행


즉, `Article.objects.all()` 은

* **Article**: 모델 클래스
* **objects**: 매니저 (쿼리 실행 진입점)
* **all()**: 모든 레코드 조회하는 쿼리 실행


---


### Django ORM ↔ SQL 대조표

| 구분                | Django ORM 코드                                                                                   | 실행되는 SQL                                                                  | 설명                                |
| ----------------- | ----------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- | --------------------------------- |
| **Create**        | `Article.objects.create(title="hello", content="world")`                                        | `INSERT INTO appname_article (title, content) VALUES ('hello', 'world');` | 새 레코드 추가                          |
| **Read (전체)**     | `Article.objects.all()`                                                                         | `SELECT * FROM appname_article;`                                          | 모든 레코드 조회                         |
| **Read (조건)**     | `Article.objects.filter(title="hello")`                                                         | `SELECT * FROM appname_article WHERE title = 'hello';`                    | 조건에 맞는 레코드 여러 개 조회                |
| **Read (단일)**     | `Article.objects.get(id=1)`                                                                     | `SELECT * FROM appname_article WHERE id = 1 LIMIT 1;`                     | 조건에 맞는 레코드 단일 조회 (없거나 2개 이상이면 오류) |
| **정렬**            | `Article.objects.order_by("title")`                                                             | `SELECT * FROM appname_article ORDER BY title ASC;`                       | 오름차순 정렬                           |
|                   | `Article.objects.order_by("-title")`                                                            | `SELECT * FROM appname_article ORDER BY title DESC;`                      | 내림차순 정렬                           |
| **Update (인스턴스)** | `python<br>article = Article.objects.get(id=1)<br>article.title = "updated!"<br>article.save()` | `UPDATE appname_article SET title='updated!' WHERE id=1;`                 | 특정 레코드 수정                         |
| **Update (바로)**   | `Article.objects.filter(id=1).update(title="updated!")`                                         | `UPDATE appname_article SET title='updated!' WHERE id=1;`                 | 조건에 맞는 레코드 일괄 수정                  |
| **Delete**        | `python<br>article = Article.objects.get(id=1)<br>article.delete()`                             | `DELETE FROM appname_article WHERE id=1;`                                 | 특정 레코드 삭제                         |
| **Count**         | `Article.objects.count()`                                                                       | `SELECT COUNT(*) FROM appname_article;`                                   | 전체 레코드 개수                         |
| **First**         | `Article.objects.first()`                                                                       | `SELECT * FROM appname_article ORDER BY id ASC LIMIT 1;`                  | 첫 번째 레코드                          |
| **Last**          | `Article.objects.last()`                                                                        | `SELECT * FROM appname_article ORDER BY id DESC LIMIT 1;`                 | 마지막 레코드                           |
| **Values**        | `Article.objects.values("title")`                                                               | `SELECT title FROM appname_article;`                                      | 특정 컬럼만 조회                         |
| **Distinct**      | `Article.objects.distinct()`                                                                    | `SELECT DISTINCT ... FROM appname_article;`                               | 중복 제거                             |

---

### Query란 ? 
- 데이터베이스에 특정한 데이터를 보여 달라는 요청
- "쿼리문을 작성한다"
  - 원하는 데이터를 얻기 위해 데이터베이스에 요청을 보낼 코드를 작성한다
- Django에서 Query가 처리되는 과정 정리
  1. 파이썬 코드 -> ORM : 개발자의 QuerySet API(파이썬 코드)가 ORM으로 전달
  2. ORM -> SQL 변환 : ORM이 이를 데이터베이스용 SQL 쿼리로 변환하여 데이터베이스에 전달
  3. DB 응답 -> ORM : 데이터베이스가 SQL 쿼리를 처리하고 결과 데이터를 ORM에 반환
  4. ORM -> QuerySet 변환 : ORM이 데이터베이스의 결과를 QuerySet(파이썬 객체) 형태로 변환하여 우리에게 전달

### QuerySet이란 ? 
- 데이터베이스에서 전달받은 객체 목록(데이터 모음)
- 순회 가능한 데이터로 1개 이상 데이터를 불러와 사용 가능함
- Django ORM을 통해 만들어진 자료형
- 단, 데이터베이스가 단일 객체를 반환할 때는 QuerySet이 아닌 모델(Class)의 인스턴스로 반환됨

---

## QuerySet API 실습
### CRUD란 ? 
- 대부분의 소프트웨어가 가지는 기본적인 데이터 처리 기능인 생성, 조회, 수정, 삭제를 묶어 이르는 말
- Django에서는 QuerySet API를 통해, 복잡한 SQL문 없이 Python 코드로 이러한 CRUD 작업을 직관적으로 수행할 수 있음

--- 

### Create

### QuerySet API 실습 사전 준비 & 데이터 생성 방법

### 1. 외부 라이브러리 설치 및 의존성 기록

* **IPython**: 일반 파이썬 셀보다 자동 완성 등 편리한 작업 환경 제공
* 설치 및 의존성 기록

  ```bash
  $ pip install ipython
  $ pip freeze > requirements.txt
  ```


### 2. Django Shell 접속하기

* **Django Shell이란?**

  * Django 프로젝트 코드를 명령창에서 실행하고 테스트할 수 있는 특별한 파이썬 환경
  * Django 환경 내에서 실행되므로 QuerySet API 구문이 실제 프로젝트에 영향을 미침
* 접속 명령어

  ```bash
  $ python manage.py shell
  ```


### 3. Django Shell 옵션

* `-v` 옵션 (기본값 1): 출력 상세도 설정 (더 많은 디버깅/진행 메시지 확인 가능)
* 예시

  ```bash
  $ python manage.py shell -v 2
  ```

  → 프로젝트에 등록된 model 들이 자동으로 import 됨


### 4. 데이터 객체를 만드는 3가지 방법

1. 빈 객체 생성 후 값 할당 및 저장
2. 초기 값과 함께 객체 생성 및 저장
3. `create()` 메서드로 한 번에 생성 및 저장


### 5. 첫 번째 방법: 빈 객체 생성 후 값 할당 및 저장

```python
# 객체 생성 (아직 저장 안 됨)
article = Article()
article.title = 'first'
article.content = 'django!'

# save() 호출 전에는 DB에 저장되지 않음
article.save()   # 저장됨
```

* `article.id` 또는 `article.pk` 로 기본키 확인 가능
* `Article.objects.all()` → 저장된 객체 조회 가능


### 6. 두 번째 방법: 초기 값과 함께 생성 후 저장

```python
article = Article(title='second', content='django!')
article.save()
```

* 역시 `save()`를 호출해야 실제 DB에 반영됨


### 7. save() 메서드란?

* 객체를 DB에 저장하는 인스턴스 메서드
* **언제 필요한가?**

  * 객체를 생성 후 DB에 저장하기 전에 **추가적인 처리**가 필요할 때
  * 예: 다른 데이터와의 관계 설정, 유효성 검사 등


### 8. 세 번째 방법: create() 메서드로 한 번에 생성 및 저장

```python
Article.objects.create(title='third', content='django!')
```

* 객체 생성 + DB 저장을 동시에 처리하는 단축 메서드
* `save()`를 따로 호출할 필요 없음


👉 요약

* **빈 객체 후 save()**
* **초기 값 넣고 save()**
* **create() 한 번에 저장**


---


## Read
### 대표적인 조회 메서드
- QuerySet 반환 메서드
  - all()
  - filter()

- QuerySet을 반환하지 않는 메서드
  - get()

### QuerySet 반환 메서드 : all()
- 전체 데이터 조회 
- ` Article.objects.all() `

### QuerySet 반환 메서드 : filter()
- 주어진 매개변수와 일치하는 객체를 포함하는 QuerySet 반환
- ` Article.objtects.filter(content='django!') `

### QuerySet을 반환하지 않는 메서드 : get()
- 주어진 매개변수와 일치하는 **객체를 반환(하나)**
- ` Article.objects.get(pk=1) `

* 만약 조건에 부합하는 객체가 없다면 ? 
=> 예외발생 
=> DoesNotExit : Article matching query does not exist.

* 만약 조건에 부합하는 객체가 여러 개면 ? 
=> 예외발생 
=> MultipleObjectsReturned : get() returned more than one Article -- it returned 2!

=> 따라서 get은 **primary key**에 쓰는 게 좋음
=> pk는 unique, not null이기 때문에 (고유성 보장)

--- 

## Update
### 데이터 수정 방법
- 인스턴스 변수를 변경 후 save 메서드 호출

```bash
# 수정할 인스턴스 조회
>>> article = Article.objects.get(pk=1)

# 인스턴스 변수를 변경
>>> article.title = 'byebye'

# 저장
>>> article.save()
```

---

## Delete
### 데이터 삭제 방법
- 삭제하려는 데이터 조회 후 delete 메서드 호출

```bash
# 삭제할 인스턴스 조회
>>> article = Article.objects.get(pk=1)

# delete 메서드 호출(삭제된 객체가 반환)
>>> article.delete()
(1, {'articles.Article': 1})

# 삭제한 데이터는 더이상 조회할 수 없음
>>> Article.obtjecs.get(pk=1)
DoesNotExist: Article matching query does not exist
```

---

## ORM with view
### 전체 게시글 조회
### ORM with view
- View 함수에서 QuerySet API 활용하기
  - view에서의 QuerySet API:
    - 웹 페이지에 보여줄 데이터를 DB에서 가져올 때 사용함
    - 사용자가 입력한 새로운 데이터를 DB에 저장할 때 사용함

- 2가지 Read(조회)
  1. 전체 게시글 조회
  2. 단일 게시글 조회



### 전체 게시글 조회

### 1. 요청 정의

`crud/urls.py`

```python
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('articles/', include('articles.urls')),
]
```

`articles/urls.py`

```python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
]
```

### TIP

* `include("articles.urls")` → `articles/` 로 시작하는 모든 요청을 `articles/urls.py` 로 넘김
* `articles/` 뒤에 아무것도 없는 경우(`path('', views.index)`)는 **`articles/` 자체**를 의미 → `index` 뷰 실행


### 2. View & Template

`articles/views.py`

```python
from .models import Article

def index(request):
    articles = Article.objects.all()
    context = {
        'articles': articles,
    }
    return render(request, 'articles/index.html', context)
```

`articles/index.html`

```html
<h1>Articles</h1>
<hr>
{% for article in articles %}
  <p>글 번호: {{ article.pk }}</p>
  <p>글 제목: {{ article.title }}</p>
  <p>글 내용: {{ article.content }}</p>
  <hr>
{% endfor %}
```

* `urls.py`에서 요청 경로 설정 → `views.py`에서 DB 조회 (`Article.objects.all()`) → `index.html`에서 `for`문으로 출력
* 이렇게 해서 **전체 게시글 조회** 기능 구현 완료


---


## Field lookups: 데이터 필터링의 마법
### 1. Field lookups 개념

* 단순 동치 비교(`=`)를 넘어서 더 상세한 조건으로 데이터를 조회할 수 있도록 Django ORM이 제공하는 기능
* 예시:

  * `'특정 단어가 포함된 제목'`
  * `'특정 날짜 이후에 작성된 글'`
* 복잡한 데이터 조회를 파이썬 코드로 간결하고 강력하게 처리 가능


### Field lookups의 간단한 예시

```python
Article.objects.filter(title__startswith='second')
```

* `title` 필드가 `'second'`로 시작하는 Article 데이터를 조회
* **구조**

  * 모델 필드명 + `__`(double underscore, 이중 밑줄) + 조회 조건 = 비교할 값
* 사용 가능 메서드: `filter()`, `exclude()`, `get()`

### 추가 예시

```python
# 내용에 'dja'가 포함된 모든 게시글 조회
Article.objects.filter(content__contains='dja')

# 제목이 'he'로 시작하는 모든 게시글 조회
Article.objects.filter(title__startswith='he')
```

### 3. 다양한 조회 조건 (Field lookups 조건)

* **exact / iexact**

  * `exact`: 대소문자를 구분하여 정확히 일치하는 값 조회
  * `iexact`: 대소문자 구분 없이 정확히 일치하는 값 조회

* **contains / icontains**

  * `contains`: 특정 값이 문자열에 포함되어 있는지 확인 (대소문자 구분)
  * `icontains`: 특정 값이 포함되었는지 확인 (대소문자 구분 없음)

* **비교 연산자 (gt, gte, lt, lte)**

  * 숫자 또는 날짜 필드에 대해 크기/작음을 비교
  * 예시:

    * `age__gt=20` → 나이가 20보다 큰 데이터
    * `created_at__lte='2024-01-01'` → 특정 날짜 이전/같은 데이터

---

## ORM, QuerySet API를 사용하는 이유
1. 데이터베이스 추상화 
- 개발자는 특정 데이터베이스 시스템에 종속되지 않고 일관된 방식으로 데이터를 다룰 수 있음

2. 생산성 향상
- 복잡한 SQL 쿼리를 직접 작성하는 대신 Python 코드로 데이터베이스 작업을 수행할 수 있음 

3. 객체 지향적 접근
- 데이터베이스 테이블을 Python 객체로 다룰 수 있어 객체 지향 프로그래밍의 이점을 활용할 수 있음 