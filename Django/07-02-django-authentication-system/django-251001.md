# Django
## Authentication System
### Logout
- 로그아웃은 Session을 Delete하는 과정
- 서버의 세션 데이터를 비우고, 클라이언트의 세션 쿠키를 삭제

### logout(request)
1. DB에서 현재 요청에 대한 Session Data를 삭제
2. 클라이언트의 쿠케이서도 Session Id를 삭제

### 로그아웃 로직 작성
1.  로그아웃 경로 url 작성
2. .../accounts/logout/url로 요청이 들어왔을 떄 실행할 logout 함수 작성
3. DB에서 현재 요청에 대한 Session Data를 삭제하고, 클라이언트의 쿠키에서도 Session Id를 삭제하는 내장 logout 함수 작성

```python
from django.contrib.auth import logout as auth_logout

def logout(reqeust):
    auth_logout(request)
    return redirect('articles:index')
```
4. 로그인한 사용자 정보를 서버에 안전하게 전송하기 위해 "POST 방식"을 사용
5. CSRF 공격을 방지하기 위해 csrf_token 작성

---

## AbstractUser class
### Abstract base classes(추상 기본 클래스)
- 몇 가지 공통 정보를 여러 다른 모델에 넣을 때 사용하는 클래스
- 데이터베이스 테이블을 만드는 데 사용되지 않으며, 대신 다른 모델의 기본 클래스로 사용되는 경우 해당 필드가 하위 클래스의 필드에 추가 됨
- 인증에 필요한 최소한의 기능만 제공

### AbstractUser class
- 관리자 권한과 함께 완전한 기능을 가지고 있는 User model을 구현하는 추상 기본 클래스
- 기본 User 모델이 가진 모든 필드가 이미 구현되어 있음

* model.Model -> class AbstractBaseUser -> class AbstractUser -> class User

### 추상 기본 클래스(Abstract Base Class) 정리

| 구분           | AbstractBaseUser                                                                 | AbstractUser                                                                 |
|----------------|----------------------------------------------------------------------------------|-------------------------------------------------------------------------------|
| 제공 필드      | **최소한의 인증 필드** (비밀번호, last_login 등)                                | **기본 User 모델의 모든 필드** (username, email 등)                          |
| 장점           | 최대의 유연성과 자유도                                                           | 개발 속도가 빠르고 편리함                                                    |
| 사용 케이스    | 이메일이 아닌 전화번호 등으로 로그인하는 등,<br>완전히 새로운 인증 체계를 만들 때 | 기존 인증 방식을 유지하면서 **프로필 사진, 닉네임 등 필드만 추가**하고 싶을 때 (대부분의 경우) |
| 예시           | 기본 피자 도우                                                                   | 토핑이 올려진 피자                                                            |


---

## 회원 가입
- User 객체를 Create 하는 과정
- 사용자로부터 아이디, 비밀번호 등의 정보를 입력 받아, DB에 새로운 User 객체를 생성하고 저장

### 회원 가입 페이지 작성
1. 회원가입 경로 url 생성
2. .../accounts/signup/url로 요청이 들어왔을 때 실행할 signup 함수 작성
3. 회원가입에 사용할 데이터를 입력 받는 UserCreationForm built-in form 사용

```python 
# accounts/views.py

from django.contrib.auth.forms import UserCreationForm

def signup(request):
    if request.method == 'POST':
        pass    
    else:
        form = UserCreationForm()
    context = {
        'form' : form 
    }
    return render(request, 'accounts/signup,html', context)
```

### UserCreationForm()
- 회원 가입시 사용자 입력 데이터를 받는 built_in ModelForm
- ModelForm이기 때문에, 유효성 검사를 통과한 데이터로 새로운 User 객체를 생성하고 데이터베이스에 저장하는 역할을 수행(이때 비밀번호는 자동으로 암호화 됨)

4. 회원가입을 위해 작성한 정보를 서버에 안전하게 전송하기 위해 **POST 방식**DMF TKDYD
5. CSRF 공격을 방지하기 위해 csrf_token 작성
6. 서보로부터 전달받은 UserCreationForm을 화면에 출력

### 회원 가입 로직 에러
- 회원가입 시도 후 에러 페이지 확인
-> Manager isn't availablel 'auth.User' has been swapped for 'accounts.User'

- 회원가입에 사용하는 UserCreationForm이 대체한 커스텀 유저 모델이 아닌 과거 Django의 기본 유저 모델로 인해 작성된 클래스이기 때문
-> model에 Custom User Model을 연결하자! 

### 커스텀 유저 모델을 사용하기 위해서 Form을 다시 작성
- Custon User model을 사용할 수 있도록 상속 후 일부분만 재작성

```python 
# accounts/forms.py

from django.contrib.auth import get_user_model
from django.contrib.auth.forms import UserCreationForm

class CustomUserCreationForm(UserCreationForm):
    class Meta(UserCreationForm.Meta):
        model = get_user_model()
```

### get_user_model()
- **현재 프로젝트에서 활성화된 사용자 모델(active user model)"을 반환하는 함수**
- 프로젝트 설정(AUTH_USER_MOEDL)에 따라 기본 User 모델일 수도, 우리가 직접 만든 커스텀 User 모델일 수도 있기 때문에 올바른 모델을 동적으로 가져오기 위해 사용
- 모델을 직접 가져오는 대신 get_user_model()을 쓰면, User 모델이 바뀌어도 코드를 수정할 필요가 없어 재사용성과 유연성이 높아짐


### User 모델을 직접 참조하지 않는 이유
- get_user_model()을 사용해 User 모델을 참조하면 커스텀 User 모델을 자동으로 반환해주기 때문
- Django는 필수적으로 User 클래스를 직접 참조하는 대신 get_user_model()을 사용해 참조해야 한다고 강조하고 있음

### 회원 가입 로직 완성
- 내장 폼이었던 UserCreationForm을 CustomUserCrationForm으로 변경

```python 
# accounts/views.py

from .forms import CustomUserCreationForm

def signup(request):
    if request.method == 'POST':
        form = CustomUserCreationForm(request.POST)
        if form.is_valid():
            form.save()
            reutrn redirect('articles:index')
    else:
        form = CustomUserCreationForm()
    context = {
        'form' : form 
    }
    return render(request, 'accounts/signup,html', context)
```

--- 

## 회원 탈퇴
- User 객체를 Delete하는 과정
- request.user.delete()를 활용해서 유저 객체 삭제를 진행

* 실제 서비스에서는 사용자를 물리적으로 삭제하는 대신, 계정을 비활성화 처리하는 경우가 더 많음

### 회원 탈퇴 로직 작성
1. 회원 탈퇴 경로 url 생성
2. .../accounts/delete/url로 요청이 들어왔을 때 실행할 delete 메서드 작성
3. 현재 로그인한 사용자 정보를 활용해 삭제하고, 메인 페이지로 이동

```python 
# accounts/views.py

def delete(request):
    request.user.delete()
    return redirect('articles:index')
```

---

## 인증된 사용자에 대한 접근 제한
1. `is_authenticated` 속성
2. `login_required` 데코레이터

---

## is_authenticatied 속성
- 사용자가 인증 되었는지 여부를 알 수 있는 User model의 읽기 전용 속성
- 인증 사용자에 대해서는 항상 True, 비인증 사용자에 대해서는 항상 False
- 사용되는 경우
    - 사용자의 로그인 상태에 따라 다른 메뉴를 보여줄 때
    - view 함수 내에서 특정 기능을 로그인한 사용자에게만 허용하고 싶을 때

* **메서드가 아닌 속성 값임을 주의**

### is_authenticated 적용하기 (1/2)

* 로그인과 비로그인 상태에서 화면에 출력되는 링크를 다르게 설정하기

```html
<!-- articles/index.html -->

{% if request.user.is_authenticated %}
  <h3>Hello, {{ user.username }}!</h3>
  <a href="{% url 'articles:create' %}">NEW</a>
  <form action="{% url 'accounts:logout' %}" method="POST">
    {% csrf_token %}
    <input type="submit" value="Logout">
  </form>

  <form action="{% url 'accounts:delete' %}" method="POST">
    {% csrf_token %}
    <input type="submit" value="회원탈퇴">
  </form>

  <a href="{% url 'accounts:update' %}">회원정보 수정</a>
{% else %}
  <a href="{% url 'accounts:login' %}">Login</a>
  <a href="{% url 'accounts:signup' %}">Signup</a>
{% endif %}
```

### is_authenticated 적용하기 (2/2)

* 인증된 사용자라면 로그인/회원가입 로직을 수행할 수 없도록 하기

```python
# accounts/views.py

def login(request):
    if request.user.is_authenticated:
        return redirect('articles:index')
    ...

def signup(request):
    if request.user.is_authenticated:
        return redirect('articles:index')
    ...
```

---

## login_required 데코레이터
2. login_required 속성
- 인증된 사용자에 대해서만 view 함수를 실행시키는 데코레이터
- 비인증 사용자의 경우 /accounts/login/ 주소로 redirect 시킴
- 사용되는 경우
    - 게시글 작성, 댓글 달기 등 누가 작성했는지 중요한 곳에서 사용

* 데코레이터 
- 기존 함수를 감싸, 특별한 기능(인증 등)을 추가하는 함수

### login_required 적용하기 (1/2)

* 인증된 사용자만 게시글을 작성/수정/삭제 할 수 있도록 수정

```python
# articles/views.py
from django.contrib.auth.decorators import login_required

@login_required
def create(request):
    pass

@login_required
def delete(request, article_pk):
    pass

@login_required
def update(request, article_pk):
    pass
```

### login_required 적용하기 (2/2)

* 인증된 사용자만 로그아웃/탈퇴/수정/비밀번호 변경 할 수 있도록 수정

```python
# accounts/views.py
from django.contrib.auth.decorators import login_required

@login_required
def logout(request):
    pass

@login_required
def delete(request):
    pass

@login_required
def update(request):
    pass

@login_required
def change_password(request):
    pass
```

---

## 회원가입 후 자동 로그인
### 회원가입 후 로그인까지 이어서 진행하려면?

* 회원가입 성공한 **user 객체**를 활용해 `login` 진행

```python
# accounts/views.py
def signup(request):
    if request.method == 'POST':
        form = CustomUserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            auth_login(request, user)
            return redirect('articles:index')
    else:
        form = CustomUserCreationForm()
    context = {
        'form': form,
    }
    return render(request, 'accounts/signup.html', context)
```

---

### UserCreationForm의 save 메서드

```python
def save(self, commit=True):
    user = super().save(commit=False)
    user.set_password(self.cleaned_data["password1"])
    if commit:
        user.save()
    return user
```

---

* 즉, `form.save()`가 반환하는 `user` 객체를 바로 `auth_login()`에 넘겨주면, 회원가입 후 자동 로그인까지 처리됨

---

## 회원 탈퇴 개선
### 탈퇴와 함께 기존 사용자의 Session Data 삭제 방법

* 사용자 객체 삭제 이후 **로그아웃 함수**를 호출해야 함
* ⚠️ 주의: **"탈퇴(1) 후 로그아웃(2)"** 순서가 바뀌면 안 됨

  * 이유: 로그아웃이 먼저 실행되면 해당 요청 객체 정보가 없어져서, 탈퇴에 필요한 유지 정보도 함께 사라지기 때문


```python
# accounts/views.py
from django.contrib.auth.decorators import login_required
from django.contrib.auth import logout as auth_logout

@login_required
def delete(request):
    request.user.delete()
    auth_logout(request)
    return redirect('articles:index')
```

 **탈퇴 시 → 먼저 `request.user.delete()`로 DB에서 삭제 → 그 후 `auth_logout(request)`로 세션 종료**해야 안전하게 동작
