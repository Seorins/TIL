# Database
## Database Modeling
- 데이터베이스 시스템을 구축하기 위해, **데이터의 구조와 관계, 제약조건**등을 설계하여 효율적이고 일관성 있는 데이터베이스를 만들기 위한 과정
- 모델링을 통해 **성능, 무결성, 신뢰성**을 보장할 수 있음


### Database Modeling의 중요성
- 효율성
  - 데이터베이스 구조를 잘 설계하면 쿼리 성능과 저장 효율이 향상
- 일관성
  - 중복과 이상 현상을 최소화하여, 데이터가 서로 모순되거나 충돌하지 않도록 함
- 무결성 보장
  - 무결성 제약 조건을 모델링 단계에서 설정해두어, 부적절한 데이터를 방지 


--


## 무결성 제약 조건
### 무결성
- 데이터베이스가 잘못된 데이터의 삽입, 수정, 삭제로부터 보호되어, **데이터의 일관성과 신뢰성**을 유지하는 것


### 대표적인 무결성 제약 조건
1. 개체 무결성
2. 참조 무결성
3. 도메인 무결성


### 1. 개체 무결성(Entity Integrity)
- **기본 키(Primary Key)**가 유일(중복 불가)하고 'NULL'값을 허용하지 않는 제약
- 핵심 원칙
  1. 각 레코든느 유일한 식별자를 가져야 함(PK 중복 불가)
  2. 기본 키는 NULL 값을 가질 수 없음(필수 값)

```SQL
CREATE TABLE Student(
  student_id INT PRIMARY KEY, -- NULL 불가능, 중복 불가능 
  name VARCHAR(50) NOT NULL
);
```

### 2. 참조 무결성(Referential Integrity)
- **외래 키와 관련된 제약**으로, **존재하지 않는 기본 키**를 참조하지 못하도록 하는 규칙
- 핵심 원칙
  1. 외래 키는 참조 대상 테이블의 기본 키 값을 참조하거나 'NULL'을 가질 수 있음
  2. 참조 대상 테이블에 존재하지 않는 기본 키 값은 사용할 수 없음
  3. 외래 키로 연결된 레코드를 삭제/수정할 때, 연ㅙ 작업(ON DELETE CASCADE 등) 또는 예외 처리를 통해 무결성 유지 

```SQL
CREATE TABLE Department(
  dept_id INT PRIMARY KEY, 
  dept_name VARCHAR(50) NOT NULL
);

CREATE TABLE Employee(
  emp_id INT PRIMARY KEY, 
  emp_name VARCHAR(50) NOT NULL, 
  dept_od INT, 
  FOREIGN KEY (dept_id) REFERENCS Department(dept_id) -- 참조 무결성 적용 
)
```


### 3. 도메인 무결성(Domain Integrity)
- 각 속성(컬럼)이 **정의된 도메인**(값의 범위, 형식)을 벗어나지 않도록 하는 제약
- 핵심 원칙
  1. 속성별로 데이터 타입, 길이, 범위 등을 정의해야 함
  2. 값이 해당 범위(도메인)를 벗어나면 삽입/수정이 제한되거나 오류 발생

```sql
CREATE TABLE Product(
  product_id INT PRIMARY KEY, 
  price DECIMAL(10, 2) CHECK (price > 0) -- 가격은 0보다 커야 함
  category VARCHAR(20) CHECK (category IN ('전자제품', '의류', '도서')) -- 특정 값만 허용
)
```


### 그 외 무결성 제약 조건
4. 고유성(UINQUE)
  - 특정 컬럼의 값이 테이블 내에서 중복되니 않도록 제한
  - 예: 이메일 주소는 한 사용자가 하나만 등록 가능

5. NULL 무결성(NOT NULL)
  - 특정 컬럼이 NULL 값을 가질 수 없도록 하는 제약

6. 일반 무결성(General Integrity)
  - 위의 특정 제약조건 외에도, 비지니스 로직에 따라 추가로 정의하는 무결성 규칙
  - 예: 은생 잔고가 0 미만이 되지 않도록 하거나, 재고 수량이 음수가 되지 않도록 하는 규칙 


----


## 모델링 과정 4단계 
### 데이터베이스 모델링 진행
요구사항 수집 및 분석 -> 걔념적 설계 -> 논리적 설계 -> 물리적 설계 


### 1. 요구사항 수집 및 분석
- 어떤 종류의 데이터를 정리하는지 정보 수집하고 어떤 작업을 수행해야 하는지 파악하는 단계
  - 개체(Entity)
    - 업무에 필요하고 유용한 정보를 저장하는 집합적인 것
    - ex) 고객, 상품
  - 속성(Attribute)
    - 관리하고자 하는 것의 의미를 더 이상 작은 단위로 분리되지 않은 데이터 단위
    - ex) 고객명, 고객 전화번호, 상품명, 상품 가격
  - 관계(Relationship)
    - 객체 사이의 논리적인 연관성을 의미하는 것
    - ex) 고객은 다수의 상품을 주문, 상품은 다수의 고객들에게 판매될 수 있음 


### 2. 개념적 설계 
- 요구사항을 기반으로 데이터베이스의 개념적 모델을 설계
- 개체(Entity)와 관계(Relationship)를 식별하고, 개체 간의 관계를 정의하여 ER Diagram을 작성


### ERD 표기 방법 (Crow’s Foot Model)

| 표기  | 의미                          |
| --- | --------------------------- |
| ─│  | 1개의 관계 표현                   |
| ─┃  | 정확히 1개 필요(반드시 있어야 함)        |
| ─○  | 0 또는 1개의 관계(선택적으로 필요)       |
| ─<  | N개의 관계 표현                   |
| ─<┃ | 1개 이상(N개의 관계 중 최소 1개 필요)    |
| ─<○ | 0개 이상(N개의 관계 중 선택적으로 존재 가능) |


### 3. 논리적 설계
- 개념적 설계(ERD) 단계에서 정한 데이터의 구조를, 실제 데이터베이스가 이해할 수 있는 테이블 형태로 변환하는 과정
  - 예를 들어 개념적 설계에서 도출된 N:M 관계는, 논리적 설계 단계에서 '중개 테이블'을 생성하여 두 개의 다대일 N:1 관계로 해소해야 함
  - 개념적 설계 (N:M) 고객 (N) <-> (M) 상품
  - 논리적 설계 (1:N, N:1) 고객 (1) -> (N) 주문 <- (1) 상품
- 개념적 설계를 기반으로 데이터베이스의 **논리적 구조**를 설계
- 테이블, 칼럼, 제약조건 등과 같은 구체적인 데이터베이스 개체를 정의
- 정규화를 수행하여 데이터의 중복을 최소화하고 일관성을 유지 


### 4. 물리적 설계
- 논리적 설계를 기반으로 데이터베이스를 실제 **저장 및 운영** 할 수 있는 형태로 변환하는 단계
- 테이블의 인덱스, 파티션, 클러스터링 등 물리적인 구조와 접근 방식을 결정
- 보안, 백업 및 복구, 성능 최적화 등을 고려하여 데이터베이스를 설정


---


## 데이터베이스 정규화 
### 정규화(Normalization)
- **데이터 중복을 최소화**하고, **이상 현상을 예방**하며, 데이터베이스 구조 변경 시 **재작업을 줄이는 목적**으로 **테이블을 구조화**하는 과정 


### 정규화 목적
1. 중복 최소화
  - 북필요한 중복 데이터를 제거해 일관성 유지 
2. 이상 현상 방지
  - 삽입, 갱신, 삭제 작업 시 발생할 수 있는 불일치 문제 예방
3. 유연성 향상
  - 데이터베이스 구조 변경 시 영향을 받는 영역을 최소화하며 유지보수성을 높임 


---


## 이상 현상(Anomaly)
- 데이터베이스를 비정상적으로 설계 했을 때 중복된 데이터가 많아져 **삽입, 갱신, 삭제** 등의 연관에서 **비일관성**이 생기는 문제 


### 이상 현상 종류
1. 삽입 이상(Insertion Anomaly)
  - 새로운 데이터를 삽입하기 위해 **불필요한 데이터도 함께** 삽입해야 하는 문제
2. 갱신 이상(Update Anomaly)
  - 중복된 데이터 중 일부만 변경되어 데이터 불일치가 발생하는 문제
3. 삭제 이상(Deletion Anomaly)
  - 어떤 데이터를 삭제할 때, **반드시 있어야 하는 정보**까지 같이 사라지는 문제 


### 삽입 이상
- 새료운 정보, 부분적인 정보만을 삽입하기 위해 불필요한 정보까지 억지로 입력해야 하는 상황이 '삽입 이상'


### 갱신 이상
- 중복된 데이터가 여러 행에 문자열 형태로 산재해 있어, 수정 시 모두 찾아서 변경해야 함
- 일부만 수정하면 불일치(데이터 모순)가 생기는 문제를 '갱신 이상'이라 함


### 삭제 이상
- 실제로는 특정 정보 자체는 남겨두고 싶었지만, 테이블 구조상 둘이 붙어 있어서 불필요하게 삭제되는 것이 '삭제 이상' 


### 문제 원인
- 하나의 테이블에 다양한 정보가 중복된 구조로 뒤섞여 있음
- 정보 간의 관계가 1:N or N:M 일 수도 있음에도, 단일 필드로 모아둔 상태 


### 해결 방법(정규화)
1. 별도 테이블로 분리
2. 테이블 간 N:M(ManyToMany) 구조를 설정


---


## 정규화 종류
- 일반적으로 1NF(제 1정규형)에서 시작해, 2NF, 3NF 순으로 진행하며, 필요에 따라 BCNF 이상(4NF, 5NF, 6NF)까지 고려하기도 함
- 실무에서는 보통 3NF 또는 BCNF까지 도달하면 정규화가 이루어졌다고 표현


### 각 정규화 단계
- 제 1 정규형 (1NF)
  - 각 속성(컬럼)이 **원자 값(Atomic Value), 즉 하나의 값**만 가져야 함
- 제 2 정규형 (2NF)
  - 제 1 정규형을 만족하면서 PK가 아닌 모든 속성이 PK에 **완전 함수 종속되어야** 한다
- 제 3 정규형 (3NF)
  - 제 2 정규형을 만족하면서 모든 속성이 PK에 **이행적 함수 종속이 되지 않아야** 한다. 
- BCNF(Boyce Codd Normalizetion Form)
  - 제 3 정규형을 만족하면서, **모든 결정자가 후보 키여야** 한다. 


---


## 제 1 정규형 (1NF)
1. **각 속성(컬럼)이 원자 값(Atomic Value)**, 즉 **하나의 값**만 가져야 함
2. **중복된 컬럼**이 없어야 함
3. **각 행(row)**이 유일하게 식별될 수 있어야 함(기본 키 존재)


---


## 제 2 정규형 (2NF)
1. **제 1정규형**을 만족해야 함
2. 복합 키(두 개 이상의 컬럼으로 이루어진 기본 키)를 사용하는 테이블에서 **모든 비(非) 기본 키 속성이 기본 키의 모든 컬럼에 완전 종속되어야 함**
  - 즉, **부분 함수 종속**(기본 키 일부 컬럼만으로 해당 속성이 결정되는 것)을 제거


### 함수 종속성(Functional Dependency)이란?
- 테이블 내의 속성들 간의 관계를 설명하는 규칙
- 만약 속성 A의 값을 알면 속성 B의 값을 **유일하게** 결정할 수 있을 때, 'B는 A에 함수적으로 종속된다'고 하며, **A->B**로 표기함
- 예시
  - 학생 테이블에서 학번을 알면 이름을 유일하게 알 수 있음 (학번 -> 이름)
  - 여기서 학번처럼 다른 속성을 결정하는 속성을 **결정자(Determinant)라고 함
- 결정자란? 
  - 관계형 테이블에서 함수적 종속성 X -> Y가 성립할 때, 좌변 X를 결정자라고 부름
  - 즉, X의 값이 같으면 Y의 값도 반드시 같다는 규칙에서 '다른 값을 결정(정의)해 주는' 속성 집합 


### 복합 키 예시 
- 학생 - 과목 예시
- '학생' 테이블의 PK는 학생 번호
- '과목' 테이블의 PK는 과목 번호
- 한 학생이 여러 과목을 듣고 (1:N), 한 과목은 여러 학생이 수강(1:N) -> N:M 관계
- 이 N:M 관계를 해소하기 위해 수강신청이라는 중개 테이블이 필요 
- 수강신청 테이블에는 (학생번호, 과목번호)가 들어감

Q. 이 테이블에서 학생번호만 PK로 쓸 수 있나요?
A. 안됩니다. 한 과목에 여러 학생이 신청하면 PK 중복

Q. 이 테이블에서 각 행(row)을 유일하게 식별하는 값은 무엇인가요?
A. 특정 학생(학생번호)이 특정 과목(과목번호)을 신청한 그 행위 자체

=> 다라서 두 값을 합친 `{학생번호, 과목번호}`가 이 테이블의 복합 기본키가 되어야만 테이블의 유일성이 보장됨 


---


## 제 3 정규형 (3NF)
1. 제 2 정규형을 만족해야 함
2. 기본 키에 대한 이행적 함수 종속(Transitive Dependency)이 없어야 함
  - A->B, B->C인 경우, A->C를 '이행 종속'이라 부름
  - 기본 키가 아닌 속성이 다른 속성(역시 기본 키가 아닌)에 의해 결정되지 않아야 함

- 예
  - 학생 테이블에서 학과 번호 -> 학과 명 -> 대학 이름 식으로 이어진다면, '학과 번호 -> 대학 이름' 부분을 별도 테이블로 분리


### 제 3 정규형 진행
- 기본 키 (PK)가 아닌 속성 간의 종속성을 제거해야 함
- 비(非) 기본 키 컬럼이 다른 비 기본 키 컬럼을 결정하면 안 됨
  - 학생 번호 -> 학생 이름/학과 (학과정은 학생번호에 의해 결정 X)
  - 학과 -> 학과장 (학과장은 학과에 의해서 결정)
  - 학생번호 -> 학과 -> 학과장으로 이어지는 **이행적 함수 종속** 발생

=> '학생정보'와 '학과정보'를 별도 테이블로 분리 


---


## BCNF(Boyce Codd Normal Form)
- 제 3 정규형을 만족해야 함
- **모든 결정자가 후보 키**여야 함 (BCNF의 핵심 정의)
- 3NF 이후에도 남아있는 이상 현상을 해결하는 더 엄격한 형태
- 기본 키가 아닌 속성이 다른 컬럼을 결정할 수 없게끔 테이블을 분해 


### 후보 키(Candidate Key)
- '모든 속성'을 결정한는 최소 결정자
- 한 테이블의 각 행(row)을 유일하게 식별할 수 있는 속성(또는 속성 조합) 중 최소성을 만족하는 키
- 후보 키의 조건
  1. 유일성(Unique): 테이블의 각 행을 **고유하게 식별**할 수 있어야 함
  2. 최소성(Minimality)
    - 불필요한 컬럼을 포함하지 않는, **최소한의 속성 조합**이어야 함
    - 예) 복합키가 후보키일 때, 단 하나의 컬럼이라도 빼면 유일성이 깨져야 함
- 한 테이블에 여러 후보 키가 있을 수 있으며, 그 중 하나를 Primary Key로 선택해야 함


### 정규화 주의 사항
- 3NF 이상으로 들어가면 BCNF, 4NF, 5NF, 6NF 등이 있으나, 지나친 분리로 인한 조인(Join) 증가나 성능 저하 등의 문제가 발생
- 따라서 업무 요구에 따라 필요한 만큼 정규화/반정규화를 조정할 것을 권장 


### 정리 
- 정규화는 중복 데이터와 이상 현상을 줄이기 위한 DB 설계 기법
- 일반적으로 1NF -> 2NF -> 3NF 순으로 진행
- 이상 현상(Anomaly)
  - 삽입/갱신/삭제 작업에서 생길 수 있는 문제점을 예방
- BCNF 
  - 3NF보다 엄격한 규칙으로, 모든 결정자는 후보 키가 되어야 함
- 정규화를 통해 데이터 무결성과 일관성을 확보하고, 유지보수 시 구조 변경 부담을 최소화 할 수 있음 