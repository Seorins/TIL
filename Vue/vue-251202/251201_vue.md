# Vue
## Single-File Components
### Component
- **재사용 가능한 코드 블록**
- 컴포넌트는 웹 페이지를 구성하는 재사용 가능한 UI
- 코드의 재사용성이 높아지고 유지보수가 매우 쉬워짐


### Component 특징
- **UI**를 독립적이고 재사용 가능한 일부분으로 분할하고 각 부분을 개별적으로 다룰 수 있음
- 자연스럽게 애플리케이션은 중첩된 Component의 트리 형태로 구성됨 


### Component 예시
- 웹 서비스는 여러 개의 Component로 이루어져 있음


### SFC(Single-File Components)
- **컴포넌트의 템플릿, 로직 및 스타일을 하나의 파일로 묶어낸 특수한 파일 형식(*.vue파일)**
- SFC는 하나의 .vue 파일 안에 컴포넌트의 HTML, JavaScript, CSS 코드를 모두 담는 Vue의 개발 방식
- 화면 구조를 담당하는 <template>, 로직을 담당하는 <script>, 스타일을 담당하는 <style> 세 부분으로 나뉨
- 관련된 코드가 한 곳에 모여 있어 컴포넌트 단위의 개발과 유지보수가 매우 편리하고 체계적으로 이루어짐 


### SFC 파일 예시
- Vue SFC는 HTML, CSS 및 JavaScript를 단일 파일로 합친 것 
- <template>, <script>, <style> 블록은 하나의 파일에서 컴포넌트 뷰, 로직 및 스타일을 독립적으로 배치

```vue
<!-- MyComponent.vue -->

<template>
  <div class="greeting">{{ msg }}</div>
</template>

<script setup>
import { ref } from 'vue'
const msg = ref('Hello World!')
</script>

<style scoped>
.greeting {
  color: red;
}
</style>
```


---


## SFC 구성 요소
- `*.vue` 파일은 세 가지 유형의 최상위 언어 블록으로 구성된다.
- `<template>`, `<script>`, `<style>`로 구성됨.
-> 언어 블록의 작성 순서는 상관 없지만 일반적으로 다음 순서로 작성한다.
  * template → script → style

```vue
<template>
  <div class="greeting">{{ msg }}</div>
</template>

<script setup>
import { ref } from 'vue'
const msg = ref('Hello World!')
</script>

<style scoped>
.greeting {
  color: red;
}
</style>
```


### `<template>` 블록

- 각 `*.vue` 파일은 최상위 `<template>` 블록을 **하나만 포함**할 수 있다.

```vue
<template>
  <div class="greeting">{{ msg }}</div>
</template>

<script setup>
import { ref } from 'vue'
const msg = ref('Hello World!')
</script>

<style scoped>
.greeting {
  color: red;
}
</style>
```


### `<script setup>` 블록

- 각 `*.vue` 파일은 `<script setup>` 블록을 **하나만 포함**할 수 있다.
  (단, 일반 `<script>`는 예외적으로 함께 존재할 수 있음)
- `<script setup>`은 컴포넌트의 `setup()` 함수를 대체하며,
  컴포넌트 인스턴스 생성 시 실행된다.
- 정의한 변수 및 함수는 동일한 컴포넌트의 템플릿에서 **자동으로 사용 가능**하다.

```vue
<template>
  <div class="greeting">{{ msg }}</div>
</template>

<script setup>
import { ref } from 'vue'
const msg = ref('Hello World!')
</script>

<style scoped>
.greeting {
  color: red;
}
</style>
```


### `<style scoped>` 블록

- `*.vue` 파일에는 여러 개의 `<style>` 태그를 포함할 수 있다.
- `scoped`가 지정되면 CSS는 **현재 컴포넌트에만 적용**된다.

```vue
<template>
  <div class="greeting">{{ msg }}</div>
</template>

<script setup>
import { ref } from 'vue'
const msg = ref('Hello World!')
</script>

<style scoped>
.greeting {
  color: red;
}
</style>
```

### 컴포넌트 사용하기

- [https://play.vuejs.org/](https://play.vuejs.org/) 에서 Vue 컴포넌트 코드를 작성하고 미리보기 할 수 있다.
- Vue SFC는 일반적인 방식으로 바로 실행할 수 없으며,
  **컴파일러를 통해 컴파일된 후 빌드되어야 실행 가능**하다.
- 실제 프로젝트에서는 **Vite**와 같은 공식 빌드(build) 도구를 사용한다.

```vue
<template>
  <div class="greeting">{{ msg }}</div>
</template>

<script setup>
import { ref } from 'vue'
const msg = ref('Hello World!')
</script>

<style scoped>
.greeting {
  color: red;
}
</style>
```


---


## SFC build tool
### Vite
- **프론트 엔드 개발 도구로써 빠른 개발 환경을 위한 빌드 도구와 개발 서버를 제공**
- Vite는 Vue 프론트엔드 개발을 위한 **빌드** 도구
- 개발 서버의 시작 속도가 매우 빠르고 코드 수정 시 실시간에 가까운 즉각적인 반영을 보여줘, 비교할 수 없이 쾌적한 개발 경험 제공
- 개발 시에는 파일을 필요할 때만 요청해 속도를 높이고, 배포 시에는 최적화된 파일로 묶어주는(번들링) 역할을 수행 


### Build
- 프로젝트의 소스 코드를 최적화하고 **번들링**하여 배포할 수 있는 형식으로 변환하는 과정
- 개발 중에 사용되는 여러 소스 파일 및 리소스(JavaScript, CSS, 이미지 등)를 최적화된 형태로 조합하여 최종 소프트웨어 제품을 생성하는 것

-> **Vite**는 이러한 **빌드 프로세스를 수행하는 데 사용되는 도구**

* 번들링
: 여러 개로 흩어진 코드 파일을 하나로 합쳐주는 작업


---


## Vue Project
### Vue Project 생성 (1/7)

- Vue Project(Application) 생성 (Vite 기반 빌드 방식)
- 아래 명령을 터미널에서 입력하여 새 Vue 프로젝트를 생성

```bash
$ npm create vue@latest
```

* 문서나 튜토리얼에서 코드 앞에 `$`가 붙어 있다면, 이는 **터미널(Terminal)** 또는 **명령 프롬프트(Command Prompt)**에 입력해야 한다는 의미
* `latest`는 해당 패키지의 **가장 최신 안정화 버전(stable version)**을 사용하겠다는 의미


### Vue Project 생성 (2/7)

- 프로젝트명 설정 단계
- `tab` 클릭 시 기본값 사용
- `enter` 클릭 시 입력한 프로젝트명으로 결정 후 진행됨

```bash
$ npm create vue@latest

Need to install the following packages:
  create-vue@3.17.0
Ok to proceed? (y)

✓ Project name (target directory): vue-project
```


### Vue Project 생성 (3/7)

- 프로젝트에 포함할 추가 설정 선택 단계
- `space` 클릭 시 체크박스를 **여러 개 선택 가능**
- `enter` 클릭 시 선택한 옵션들로 확정 후 다음 단계 진행

```text
Select features to include in your project: (↑/↓ to navigate, space to select, a to toggle all, enter to confirm)

□ TypeScript
□ JSX Support
□ Router (SPA development)
□ Pinia (state management)
□ Vitest (unit testing)
□ End-to-end Testing
□ ESLint (error prevention)
□ Prettier (code formatting)
```


### Vue Project 생성 (4/7)

- **실험용 기능 설치 여부**를 묻는 단계
- 실험용 기능은 버그가 있거나 아직 안정적이지 않을 수 있음
- 일반적인 프로젝트에서는 반드시 사용할 필요 없음

```text
Select experimental features to include in your project: (↑/↓ to navigate, space to select, a to toggle all, enter to confirm)

□ Oxlint (experimental)
□ rolldown-vite (experimental)
```


### Vue Project 생성 (5/7)

- 프로젝트 생성이 완료되면 아래와 같은 안내 메시지가 출력된다.
- 이후 명령어를 순서대로 입력해 개발 서버를 실행할 수 있다.

```bash
cd vue-project
npm install
npm run dev
```

- 선택 사항(optional): Git 초기화

```bash
git init && git add -A && git commit -m "initial commit"
```


### Vue Project 생성 (6/7)

- 프로젝트 폴더로 이동

```bash
$ cd vue-project
```

- 패키지 설치

```bash
$ npm install
```

- 설치 완료 시 출력 예시

```text
added 145 packages, and audited 146 packages in 12s

43 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities
```


### Vue Project 생성 (7/7)

- Vue 프로젝트 서버 실행

```bash
$ npm run dev
```

- 실행 후 출력 예시

```text
VITE v0.0.4  ready in 1216 ms

➜  Local:   http://localhost:5173/
➜  Network: use --host to expose
➜  press h to show help
```

- 브라우저에서 `http://localhost:5173` 접속 시 기본 화면이 표시된다.

---

- Vue 프로젝트 디렉터리 구조 예시

```text
vue-project
├─ node_modules
├─ public
│  └─ favicon.ico
├─ src
│  ├─ assets
│  ├─ components
│  ├─ App.vue
│  └─ main.js
├─ .gitignore
├─ index.html
├─ jsconfig.json
├─ package.json
├─ package-lock.json
├─ README.md
└─ vite.config.js
```


---


## Node Package Manager (NPM)

- **Node.js의 기본 패키지 관리자**
- NPM은 개발자들이 만든 JavaScript 패키지를 모아놓은 거대한 저장소이며,
  패키지를 쉽게 설치하고 관리할 수 있게 해주는 **명령어 도구**
- `npm install` 명령어 하나로 다양한 패키지를 간편하게 다운로드하여 사용할 수 있음
- 프로젝트에서 사용된 모든 패키지 목록과 버전은 **package.json** 파일에 기록됨
- 이를 통해 다른 사람과 협업하거나, 다른 환경에서 동일한 개발 환경을 쉽게 구축할 수 있도록 도와줌


### Node JS

- Chrome의 **V8 JavaScript 엔진**을 기반으로 동작하는 **Server-Side 실행 환경**
- 원래 브라우저 안에서만 동작하던 JavaScript를 **브라우저가 아닌 서버에서도 실행**할 수 있게 해줌
  -> 프론트엔드와 백엔드를 동일한 언어(JavaScript)로 개발할 수 있게 됨.
- NPM을 활용해 수많은 오픈 소스 패키지와 라이브러리를 제공하여 개발자들이 손쉽게 코드를 공유하고 재사용할 수 있게 함


---


## 모듈과 번들러
### Module

- **프로그램을 구성하는 독립적인 코드 블록(*.js 파일)**
- 개발하는 애플리케이션의 크기가 커지고 복잡해지면서 파일 하나에 모든 기능을 담기 어려워짐
- 자연스럽게 파일을 여러 개로 분리하여 관리하게 됨
-> 이때 **분리된 각 파일**이 바로 **모듈(Module)** (*.js 파일 하나가 하나의 모듈)


### Module의 한계
- 애플리케이션이 점점 더 발전함에 따라 처리해야 하는 JavaScript 모듈의 개수도 극적으로 증가
- 이러한 상황에서 성능 병목 현상이 발생하고 모듈 간의 **의존성***(연결성)이 깊어지면서 특정한 곳에서 발생한 문제가 어떤 모듈 간의 문제인지 파악하기 어려워 짐
- 복잡하고 깊은 모듈 간 의존성 문제를 해결하기 위한 도구가 필요
-> **Bundler**


### Bundler

- **여러 모듈과 파일을 하나(혹은 여러 개)의 번들로 묶고 최적화하여 사용할 수 있게 만들어주는 도구**
- Bundler는 여러 개로 나뉜 JavaScript 모듈 파일들을 하나의 파일로 합쳐주는 도구
- 브라우저가 수많은 파일을 각각 요청하여 생기는 네트워크 부담을 줄이고,
  코드를 브라우저가 이해할 수 있는 형태로 변환해줌
- 최종적으로 웹사이트의 로딩 속도를 높이고 성능을 최적화하는 역할을 함


### Bundler의 역할

- 의존성 관리, 코드 최적화, 리소스 관리 등
- Bundler가 하는 작업을 **Bundling**이라 함

* Vite는 Rollup이라는 Bundler를 사용하며,
  개발자가 별도로 기타 환경설정에 신경 쓰지 않도록 모두 설정해두고 있음


* 번들링의 핵심 목표는 여러 파일을 하나로 묶어 HTTP 요청을 줄여, 웹 로딩 속도를 개선하는 것
* JS뿐 아니라 CSS, 이미지 등 모든 정적 자원을 함께 처리하고 최적화하는 역할도 함
* import하지 않은 코드는 ‘트리 쉐이킹’을 통해 최종 번들 파일에서 자동으로 제거됨


---


## Vue Project 구조 
### 기본 구조 

1. public 디렉토리
2. src 디렉토리
   1. src/assets
   2. src/components
   3. src/App.vue
   4. src/main.js
3. index.html
4. 기타 설정 파일
5. 패키지 관리 파일
   1. package.json
   2. package-lock.json
   3. node_modules


### 1. public 디렉토리

* 주로 다음 정적 파일을 위치시키는 곳
  - 소스코드에서 참조되지 않는 코드
  - 항상 같은 이름을 갖는 코드
  - import 할 필요 없는 코드

* 항상 root 절대 경로를 사용하여 참조
  - public/icon.png는 소스 코드에서 **/icon.png**로 참조할 수 있음


### 2. src 디렉토리

- 프로젝트의 주요 소스 코드를 포함하는 곳
- 실제로 우리가 작업하게 될 대부분의 소스 코드가 위치
- 컴포넌트, 스타일, 라우팅 등 프로젝트의 **핵심 코드를 관리**


### 2-1. src/assets

- 프로젝트 내에서 사용되는 정적 자원
  (이미지, 폰트, 스타일 시트 등)을 관리
- 컴포넌트 자체에서 참조하는 내부 파일을 저장하는 데 사용
- 컴포넌트가 아닌 곳에서는 public 디렉토리에 위치한 파일을 사용


### 2-2. src/components

- 프로젝트의 주요 소스 코드를 포함하는 곳
- 실제로 우리가 작업하게 될 대부분의 소스 코드가 위치
- 컴포넌트, 스타일, 라우팅 등 프로젝트의 핵심 코드를 관리


### 2-3. src/App.vue

- Vue 앱의 Root 컴포넌트
- 다른 하위 컴포넌트들을 포함
- 애플리케이션 전체의 레이아웃과 공통적인 요소를 정의


### 2-4. src/main.js

- Vue 애플리케이션을 초기화하고 App.vue를 DOM에 마운트하는 시작점
- 필요한 라이브러리를 import하고 전역 설정을 수행


### 3. index.html

- Vue 앱의 기본 HTML 파일
- main.js에서 App.vue 컴포넌트를 렌더링하고, index.html 특정 위치를 마운트 시킴
  -> Vue 앱이 **SPA**인 이유
- 필요한 스타일 시트, 스크립트 등의 외부 리소스를 로드할 수 있음
  (ex. bootstrap CDN)


* 마운트
: 만들어진 앱을 HTML로 보여주는 것

* SPA
: 하나의 페이지 안에서, 내용만 바꿔가며 보여주는 웹 앱


### 4. 기타 설정 파일

* jsconfig.json
  - **컴파일 옵션**, 모듈 시스템 등 설정

* vite.config.js
  - Vite 프로젝트 설정 파일
  - **플러그인**, 빌드 옵션, 개발 서버 설정 등


---


## 패키지 관리 
### 5-1. package.json

- 프로젝트에 관한 기본 정보와 패키지 의존성을 정의하는 “설계도” 파일 (메타데이터 파일)
- 프로젝트가 어떤 패키지를 사용하고, 어떤 스크립트를 실행할 수 있는지 명시
- npm install 시 이를 참조하여 패키지를 설치
  - 어떤 패키지를 설치해야 하는지 결정하는 기준 제공


### 5-1. package.json 특징

* 프로젝트 메타 데이터
  - 프로젝트 이름, 버전, 스크립트 명령, 패키지 의존성 등의 정보가 명시됨

* 의존성(Dependencies) 목록
  - 어떤 패키지를 사용하는지, 어떤 버전 범위를 허용하는지를 기록

* “집을 짓기 전에 필요한 재료 목록과 건축 계획서”
  - 필요한 재료(패키지)와 대략적 규격(버전 범위)을 알려주는 문서


### 5-2. package-lock.json

- package.json을 기반으로 실제 설치된 패키지들의 **정확한 버전 정보**를 기록하는 파일
- 실제로 어느 버전의 패키지가 설치되었는지 확정하고 기록
- 다른 환경에서도 동일한 패키지 구성을 재현 가능하게 함


### 5-2. package-lock.json 특징

* 정확한 버전 고정
  - 프로젝트를 설치할 때 실제로 어떤 버전의 패키지가 설치되었는지를 기록

* 빌드 안정성 보장
  - 협업 또는 배포 환경에서, 모든 개발자가 동일한 패키지 버전을 사용하도록 보장

* 자동 관리
  - npm install 결과가 반영되어 매번 자동 업데이트

-> “장바구니에 담긴 물건들의 정확한 브랜드와 생산일자가 적힌 구매 내역서”
  (실제 구매된 물건(패키지)의 구체적 스펙을 담은 문서)


### node_modules

- package.json과 package-lock.json에 따라 실제로 설치된 모든 패키지가 저장되는 곳
- 프로젝트 실행 시 필요한 모든 라이브러리와 코드 파일을 보관
- 애플리케이션 구동 시 참조되는 실제 데이터 저장소


### node_modules 특징

* npm install을 통해 설치된 모든 패키지(모듈)들이 실제로 저장
  - 개발 시 직접 수정할 필요는 없으며, npm install 시 자동 관리됨
  - 직접 수정하지 않고, 필요 시 npm install로 언제든 재생성 가능

* 용량이 매우 클 수 있으며, 협업 시 일반적으로 Git으로 추적하지 않음 (.gitignore에 포함)

-> “계획서와 내역서대로 확보한 실제 건축 자재들이 쌓여 있는 창고”
  (설계와 구매 목록을 바탕으로 실제 물리적 자재(파일)들이 모여 있는 장소)


### 패키지 관리 정리

* package.json
  - 어떤 패키지가 필요하고 어떤 버전 범위를 허용할지 정의하는 **설계도**

* package-lock.json
  - 실제로 설치한 패키지의 정확한 버전을 기록하는 **상세 내역서**

* node_modules
  - 이 설계도와 내역서에 따라 내려 받은 실제 패키지 **자재 창고**


---


## Vue Component 활용
### 컴포넌트 사용 3단계

1. 사전 준비
2. 컴포넌트 파일 생성
3. 컴포넌트 등록(import)


### 1. 사전 준비
- 초기 생성된 모든 컴포넌트 삭제 (App.vue 제외)
- App.vue 코드 초기화

```vue
<!-- App.vue -->

<template>
  <h1>App.vue</h1>
</template>

<script setup>
</script>
```


### 2. 컴포넌트 파일 생성

- MyComponent.vue 생성

```vue
<!-- MyComponent.vue -->

<template>
  <div>
    <h2>MyComponent</h2>
  </div>
</template>

<script setup>
</script>
```


### 3. 컴포넌트 등록

- App 컴포넌트에 MyComponent를 등록
- App(부모) – MyComponent(자식) 관계 형성
- “@” 는 “src/” 경로를 뜻하는 약어

```vue
<!-- App.vue -->

<template>
  <h1>App.vue</h1>
  <MyComponent />
</template>

<script setup>
// import MyComponent from './components/MyComponent.vue'
import MyComponent from '@/components/MyComponent.vue'
</script>
```


### 결과 확인

- Vue dev tools를 사용해 컴포넌트 관계 형성 확인


### 추가 하위 컴포넌트 등록 후 활용

- 컴포넌트의 재사용성 확인하기
- MyComponentItem은 MyComponent의 자식 컴포넌트

```vue
<!-- MyComponentItem.vue -->

<template>
  <p>MyComponentItem</p>
</template>
```

```vue
<!-- MyComponent.vue -->

<template>
  <div>
    <h2>MyComponent</h2>
    <MyComponentItem />
    <MyComponentItem />
    <MyComponentItem />
  </div>
</template>

<script setup>
import MyComponentItem from '@/components/MyComponentItem.vue'
</script> 
```


### Component 이름 지정 스타일 가이드

- 스타일 가이드 살펴보기


---


## Virtual DOM
### Vue에서는 직접적으로 DOM에 접근하는 것을 권장하지 않음

- JavaScript에서 사용하는 DOM 접근 관련 메서드 사용 금지
- querySelector, createElement, addEventListener 등

- Vue의 ref()와 Lifecycle Hooks 함수를 사용해 간접적으로 접근하여 조작할 것
-> 이유는 **성능과 코드의 예측 가능성을 극대화**하기 위해서

-> 이를 가능하게 하는 것이 **가상돔(Virtual DOM)**


### Virtual DOM

- **가상의 DOM을 메모리에 저장하고 실제 DOM과 동기화하는 프로그래밍 개념**

- Virtual DOM은 실제 DOM의 모습을 그대로 복사한, 메모리상에만 존재하는 ‘가상 설계도’
- 데이터가 변경되면, Vue는 실제 DOM을 바로 건드리지 않고 이 가상 설계도 위에서 변경 사항을 미리 시뮬레이션하고 차이점을 계산
- 그리고 계산된 최소한의 변경 사항만 실제 DOM에 딱 한 번 적용하므로 불필요한 렌더링을 줄여 성능을 크게 향상시킴


### Virtual DOM

- 실제 DOM과의 변경 사항 비교를 통해 **변경된 부분만 실제 DOM에 적용**하는 방식
- 웹 애플리케이션의 성능을 향상시키기 위한 Vue의 내부 렌더링 기술

```html
<!-- index.html -->

<!DOCTYPE html>
<html lang="en">
<head>
</head>
<body>
  <!-- Vue의 영역 (Virtual DOM) -->
  <div id="app"></div>

  <script type="module" src="/src/main.js"></script>
</body>
</html>
```


### Virtual DOM 내부 렌더링 과정

1. 작성한 HTML 템플릿을 Virtual DOM을 그려내는 설계도(렌더 함수 코드)로 변환
2. 렌더 함수 코드를 바탕으로 Virtual DOM을 생성
3. Virtual DOM을 실제 DOM에 마운트
4. 컴포넌트의 데이터(반응형 상태)가 바뀔 때마다 새로운 가상돔을 만들어 이전과 비교하고,
   바뀐 부분만 효율적으로 찾아 실제 DOM을 업데이트


### Virtual DOM 패턴의 장점

1. **효율성**
  - 실제 DOM 조작을 최소화하고, 변경된 부분만 업데이트하여 성능을 향상

2. **반응성**
  - 데이터의 변경을 감지하고, Virtual DOM을 효율적으로 갱신하여 UI를 자동으로 업데이트

3. **추상화**
  - 개발자는 실제 DOM 조작을 Vue에게 맡기고 컴포넌트와 템플릿을 활용하는 추상화된 프로그래밍 방식으로 원하는 UI 구조를 구성하고 관리할 수 있음


### Virtual DOM 주의사항

* 실제 DOM에 직접 접근하지 말 것
  - JavaScript에서 사용하는 DOM 접근 관련 메서드(querySelector, createElement, …) 사용 금지
  - 아래와 같은 예측 불가능한 문제가 발생할 수 있음
    1. 데이터와 화면의 불일치(상태 불일치)
    2. 예측 불가능한 렌더링
    3. 코드의 복잡성 증가

-> Vue의 ref()와 Lifecycle Hooks 함수를 사용해 **간접적으로 접근하여 조작할 것**


### 직접 DOM 엘리먼트에 접근해야 하는 경우

- ref 속성을 사용하여 특정 DOM 엘리먼트에 **직접적인 참조**를 얻을 수 있음

```vue
<template>
  <input ref="input" />
</template>

<script setup>
import { ref, onMounted } from 'vue'

// 변수명은 템플릿 ref 값과 일치해야 함
const input = ref(null)

onMounted(() => {
  console.log(input.value)  // <input>
})
</script>
```


---


## Coposition API & Option API
### Vue를 작성하는 2가지 스타일

### Composition API

- import해서 가져온 API 함수들을 사용하여 컴포넌트의 로직을 정의
- Vue3에서의 권장 방식

```vue
<template>
  <button @click="increment">{{ count }}</button>
</template>

<script setup>
import { ref, onMounted } from 'vue'

const count = ref(0)
function increment() {
  count.value++
}

onMounted(() => {
  console.log(`숫자 세기의 초기값은 ${count.value}`)
})
</script>
```

---

### Option API

- data, methods 및 mounted 같은 객체를 사용하여 컴포넌트의 로직을 정의
- Vue2에서의 작성 방식 (Vue3에서도 지원)

```vue
<template>
  <button @click="increment">{{ count }}</button>
</template>

<script>
export default {
  data() {
    return { count: 0 }
  },
  methods: {
    increment() {
      this.count++
    }
  },
  mounted() {
    console.log(`숫자 세기의 초기값은 ${this.count}`)
  }
}
</script>
```


### API 별 권장 사항

* **Composition API + SFC**
  - 규모가 있는 앱의 전체를 구축하려는 경우

* **Option API**
  - 빌드 도구를 사용하지 않거나 복잡성이 낮은 프로젝트에서 사용하려는 경우


---


## Single Root Element
### 모든 컴포넌트에는 최상단 HTML 요소가 작성되는 것이 권장

- 가독성, 스타일링, 명확한 컴포넌트 구조를 위해 각 컴포넌트에는 **최상단 HTML 요소(Single Root Element)**를 작성해야 함

```vue
<!-- bad -->
<template>
  <h2>Heading</h2>
  <p>Paragraph</p>
  <p>Paragraph</p>
</template>

<!-- good -->
<template>
  <div>
    <h2>Heading</h2>
    <p>Paragraph</p>
    <p>Paragraph</p>
  </div>
</template>
```


---


## CSS scoped
### **CSS scoped 속성**

- `<style scoped>`를 사용하면 해당 컴포넌트 내부의 스타일이 현재 컴포넌트 내부 요소에게만 적용되도록 범위를 제한하는 기능
- 스타일이 컴포넌트 바깥으로 유출되거나, 다른 컴포넌트에서 정의한 스타일이 현재 컴포넌트를 침범하지 않도록 막아 줌

```
<style scoped> </style>
```

* CSS Scoped를 사용하지 않는다면?
  - `<style>`에 scoped를 붙이지 않으면, 해당 스타일은 전역(모든 컴포넌트)에 영향을 미침
  - 예를 들어, 다른 컴포넌트에서도 div 태그를 사용했다면 그 스타일이 함께 적용됨


### 부모-자식 관계에서의 스타일 전파 (1/2)

- 일반적으로 scoped 스타일은 부모 컴포넌트의 스타일이 자식 컴포넌트에 영향을 미치지 않음
- 하지만 예외적으로 자식 컴포넌트의 **"최상위 요소(root element)"** 에는
  **부모 컴포넌트의 scoped 스타일도 영향을 줄 수 있음**
- 이는 부모가 자식 컴포넌트를 레이아웃 할 때 필요한 경우가 있기 때문
  (예: 자식 컴포넌트의 외곽 박스 크기나 마진 조정)

➤ 즉, 자식 컴포넌트의 가장 바깥쪽을 감싸는 요소에 한해서는 부모의 scoped 스타일 적용이 **의도적으로 허용되어 있음**


### 부모-자식 관계에서의 스타일 전파 (2/2)

- 다음과 같이 App(부모) 컴포넌트에 적용한 스타일에 scoped가 작성 되어 있지만,
  **MyComponent(자식)의 최상위 요소(div)는 부모와 본인의 CSS 모두의 영향을 받기 때문에**
  부모 컴포넌트에 지정한 스타일이 적용됨.

```vue
<!-- App.vue -->
<template>
  <h1>App.vue</h1>
  <MyComponent />
</template>

<style scoped>
div {
  color: red;
}
</style>
```

```vue
<!-- MyComponent.vue -->
<template>
  <div>
    <h2>MyComponent</h2>
  </div>
</template>
```


### CSS scoped를 적용한 이유

- Vue는 부모 컴포넌트가 자식 컴포넌트의 최상위 요소 스타일을 제어할 수 있어야 레이아웃(배치) 목적을 쉽게 달성할 수 있다고 판단했기 때문
- 이로 인해 자식 컴포넌트의 root element는 부모와 자식 모두의 scoped 스타일이 영향을 미칠 수 있음

-> 최상위 App 컴포넌트에서 레이아웃 스타일을 전역적으로 구성할 수 있지만,
  다른 모든 컴포넌트는 **범위가 지정된 스타일을 사용하는 것을 권장**


---


## Scaffolding(스캐폴딩)

- **새로운 프로젝트나 모듈을 시작할 때, 초기 구조와 코드를 자동으로 생성하는 과정**
- 스캐폴딩은 새 건물을 지을 때 세우는 뼈대처럼, 새로운 프로젝트를 시작할 때 필요한 기본적인 파일과 폴더 구조를 자동으로 생성해주는 기능
- npm create vue@latest 같은 명령어로, 필요한 초기 파일, 코드가 자동으로 만들어짐
- 이를 통해 초기 설정 작업에 시간을 낭비하지 않고, 곧바로 개발에 집중할 수 있도록 도와줌


### 관심사의 분리가 파일 유형의 분리와 동일한 것이 아님

* “HTML/CSS/JS를 한 파일에 혼합하는 게 괜찮을까?”

➤ 프론트엔드 앱의 사용 목적이 점점 더 복잡해짐에 따라, 단순 파일 유형으로만 분리하게 될 경우 프로젝트의 목표를 달성하는 데 도움이 되지 않게 됨

**“파일 타입”에 따른 결합 → “사용 목적”에 따른 결합**


---


## 패키지 관리 주의사항 

1. **npm install을 입력하는 위치**
  - 항상 프로젝트 루트 디렉토리(프로젝트를 생성한 폴더)에서 실행

2. **node_modules 폴더 관리 주의**
  - 필요할 때마다 npm install을 통해 재생성할 수 있으므로, 직접 수정하거나 Git으로 관리할 필요 없음

3. **package.json과 package-lock.json 직접 편집 자제**
  - npm install 패키지명 명령을 통해 자동 업데이트하는 것이 안전

4. **문제가 발생했을 때 재설치 고려**
  - 패키지 버전 충돌이나 이상 동작이 의심될 때는 node_modules 폴더를 삭제한 뒤 다시 npm install을 실행

