# OOP2 & Exception
## 상속(Ingeritance)
- 한 클래스(부모)의 속성과 메서드를 다른 클래스(자식)가 물려 받는 것
- 부모 클래스와 자식 클래스 간의 상하 관계가 형성되고, 위쪼게 있는 부모 클래스가 본인의 속성과 메서드를 아래쪽에 있는 자식에게 넘겨주는 것이 상속입니다. 
- 속성과 메서드를 자식에게 넘겨주는 과정을 상속 과정이라고 합니다.


### 상속이 필요한 이유
1. 코드 재사용
  - 상속을 통해 기존 클래스의 속성과 메서드를 재사용할 수 있음
  - 기존 클래스를 수정하기 않고도 기능을 확장할 수 있음
2. 계층 구조
  - 상속을 통해 클래스들 간의 계층 구조극 형성할 수 있음
  - 부모 클래스와 자식 클래스 간의 관계를 표현하고, 더 구체적인 클래스를 만들 수 있음 
3. 유지 보수의 용이성
  - 상속을 통해 기존 클래스의 수정이 필요한 경우, 해당 클래스만 수정하면 되므로 유지 보수가 용이해짐
  - 코드의 일관성을 유지하고, 수정이 필요한 범위를 최소화 할 수 있음

---

## 메서드 오버라이딩(Method Overriding)
- 부모 클래스의 메서드를 같은 이름, 같은 파라미터 구조로 재정의하는 것
- 자식 클래스에서 메서드를 다시 정의하면, 부모 클래스의 메서드 대신 자식 클래스의 메서드가 실행됨
- 오버라이딩은 동일한 이름과 매개변수를 사용하지만, 내부 동작을 원하는 대로 바꿀 수 있게 해줌
- 부모 클래스의 기능을 유지하면서도 일부 동작을 맞춤형으로 바꾸고 싶을 때 유용함.

### [참고] 오버로딩(overloading)
- 같은 이름, 다른 파라미터를 가진 여러 메서드를 정의하는 것(파이썬은 미지원)
- 파이썬은 실제로 하나의 메서드만 인식하며, 인자의 형태가 다르다는 이유로 메서드를 여러 개 구분하여 불러주지 않음

---

## 다중 상속
- 둘 이상의 상위 클래스부터 여러 행동이나 특징을 상속받을 수 있음
- 상속받은 모든 클래스의 요소를 활용 가능
- 중복된 속성이나 메서드가 있는 경우 **상속 순서에 의해 결정됨**

### 다이아몬드 문제 (The diamond problem)
- 두 클래스 B와 C가 A에서 상속되고 클래스 D가 B와 C 모두에서 상속될 때 발생하는 모호함
- B와 C가 재정의한 메서드가 A에 있고 D가 이를 재정의하지 않은 경우라면
- D는 B의 메서드 중 어떤 버전을 상속하는가? 아니면 C의 메서드 버전을 상속하는가?
  
### 파이썬에서의 해결책
- MRO(Method Resolution Order) 알고리즘을 사용하여 클래스 목록을 생성
- 부모 클래스로부터 상속된 속성을 정해진 내부 알고리즘에 따라 검색
- 이 순서는 기본적으로 왼쪽에서 오른쪽으로 진행되며, 계층 구조에서 중복되는 클래스는 한 번만 확인 
- 그래서, 속성이 D에서 발견되지 않으면 B에서 찾고, 거기에서도 발견되지 않으면, C에서 찾고, 이런 식으로 진행됨

### MRO(Method Resolution Order)
- 파이썬이 메서드를 찾는 순서에 대한 규칙 메서드 결정 순서
- MRO는 다중 상속에서 어떤 부모 클래스의 메서드를 먼저 사용할지 순서를 정의
- 파이썬은 미리 정해진 MRO를 통해 다중 상속 환경에서도 예측 가능한 방식으로 메서드 탐색이 이루어질 수 있도록 함

---
 
## super() 메서드
- 메서드 해석 순서(MRO)에 따라, 현재 클래스의 부모(상위) 클래스의 메서드나 속성에 접근할 수 있게 해주는 내장 함수
- super()를 사용하면 직접 부모 클래스 이름을 적지 않아도 MRO에 따라 자동으로 올바른 메서드를 찾아 실행할 수 있음
- 다중 상속에서 super()를 호출하면 상속 순서에 맞춰 여러 부모 클래스의 메서드를 순차적으로 실행할 수 있음
- 생성자나 오버라이딩 된 메서드에서 super()를 호출하면 부모 클래스의 초기화나 로직을 그대로 활용 가능

### super() 특징
- 단순히 "부모 클래스의 메서드를 호출"하기 위한 용도 뿐만 아니라, 다중 상속(Mutiple Inheritance)이 있을 때도 올바른 순서(MRO)에 따라 상위 클래스의 메서드를 찾아 실행하기 위해 super()를 사용

### super()의 2가지 사용 사례
1. 단일 상속 구조
2. 다중 상속 구조

### super() 사용 예시 (단일 상속)
- 명시적으로 부모 클래스 이름을 적지 않아도 부모 메서드를 안전하게 호출할 수 있음
- 나중에 클래스 이름이 바뀌거나 상속 구조가 변경되어도 super() 호출 부분을 그대로 사용할 수 있어 유지보수성이 향상

### 단일 상속 구조에서 super 함수
- "부모 클래스의 생성자(또는 메서드)를 호출하기 위해 사용"
- 명시적으로 이름을 지정하지 않고 부모 클래스를 참조할 수 있으므로, 코드를 더 유지 관리하기 쉽게 만들 수 있음
- 클래스 이름이 변경되거나 부모 클래스가 교체되어도 super()를 사용하면 코드 수정이 더 적게 필요 

### TIP 
- 단일 상속에서는 super()를 사용해 부모 클래스를 직접 지정하지 않고 메서드를 호출
- 이렇게 하면 나중에 부모 클래스 이름이 바뀌거나 계층이 수정돼도 코드 유지 관리가 훨씬 수월해집니다.

---

### 다중 상속 구조에서의 super 함수
- MRO(메서드 해석 순서)에 따라 각 클래스의 메서드를 찾아가기 때문에, 단순히 직계 부모만이 아니라 다중 상속 관계에서도 적절한 상위 클래스의 메서드를 안전하게 호출할 수 있음
- 이를 통해 복잡한 상속 구조에서도 코드를 유연하고 깔끔하게 유지할 수 있음

### super() 정리
- super()를 사용할 때는 MRO를 잘 이해하고 있어야 함 
- ClassNsme.__mro__ 또는 ClassName.mro()를 확인해 MRO 순서를 파악한 뒤 적절히 활용하는 연습을 하면, 보다 복잡한 상속 구조에서도 코드를 잘 관리할 수 있음

### MRO가 필요한 이유
- 부모 클래스들이 여러 번 액세스 되지 않도록, 각 클래스에서 지정된 왼쪽에서 오른쪽으로 가는 순서를 보존하고, 각 부모를 오직 한 번만 호출하고, 부노들의 우선순위에 영향을 주지 않으면서 서브 클래스를 만드는 단조적인 구조 형성
-> 프로그래밍 언어에서 신뢰성 있고 확장성 있는 클래스를 설계할 수 있음
-> 클래스 간의 메서드 호출 순서가 예측 가능하게 유지되며, 코드의 재사용성과 유지보수성이 향상됨

--- 

## 에러와 예외
### 디버깅
### 버그(bug)
- 소프트웨어에서 발생하는 오류 또는 결함
- 프로그램의 예상된 동작과 실제 동작 사이의 불일치 

## 디버깅(Debugging)
- 소프트웨어에서 발생하는 버그를 찾아내고 수정하는 과정
- 프로그램의 오작동 원인을 식별하여 수정하는 작업
- 디버깅은 코드 실행 과정에서 변수 값이나 흐름을 점검하며 문제의 정확한 위치와 원인을 찾아내는 과정
- 효과적인 디버깅을 위해 단계별로 코드를 실행하거나 로그를 출력해 프로그램 상태를 확인

### 디버깅 방법
1. print 함수 활용
  - 특정 함수 결과, 반복/조건 결과 등 나눠서 생각, 코드를 bisection으로 나눠서 생각
2. 개발 환경(text editor, IDE)등에서 제공하는 기능 활용
3. Python tutor 활용 
4. 뇌 컴파일, 눈 디버깅

---

## 에러 (Error)
- 프로그램 실행 중에 발생하는 예외 상황

### 파이썬의 에러 유형
1. 문법 에러(syntax Error)
 - 프로그램의 구문이 올바르지 않은 경우 발생 (오타, 괄호 및 콜론 누락 등의 문법적 오류)
2. 예외(Exceoption)
  - 프로그램 실행 중에 감지되는 에러

### 문법 에러
- 문법 에러는 코드 실행 이전에 발생하므로, 에디터에서 제공하는 밑줄, 색상, 자동완성 등을 적극 활용해 감지

---

## 예외(Exception)
- 프로그램 실행 중에 감지되는 에러 
- 예외는 프로그램이 잘못된 동작을 시도할 때 자동으로 감지됨
- 이런 상황을 처리하지 않으면 프로그램은 즉시 종료됨

### 내장 예외(Built-in Exception)
- 예외 상황을 나타내는 예외 클래스들
- 내장 예외는 파이썬에 이미 저장되어 있으며, 특정 예외 상황에 대한 처리를 위해 사용

---

## 예외 처리(Exception Handling)
- 예외가 발생햇을 때 프로그램이 비정상적으로 종료되지 않고, 적절하게 처리할 수 있도록 하는 방법
- 예외 처리를 통해 오류가 발생해도 프로그램의 흐름을 이어나갈 수 있음
- Python에서는 try, except 구문을 사용해 특정 예외를 잡아내고 원하는 동작을 수행할 수 있음
- 예외처리를 구현하면 프로그램 사용자에게 오류 메시지를 보유하거나 대체 로직을 실행할 수 있음

### 예외처리 사용 구문
- try
  - 예외가 발생할 수 있느 코드 작성
- except
  - 예외가 발생했을 때 실행할 코드 작성
- else
  - 예외가 발생하지 않았을 때 실행할 코드 작성
- finally
  - 예외 발생 여부와 상관없이 항상 실행할 코드 작성
  
---

## try & except
- try 블록 안에는 예외가 발생할 수 있는 코드를 작성
- except 블록 안에는 예외가 발생했을 때 처리할 코드를 작성
- 예외가 발생하면 프로그램 흐름은 try 블록을 빠져나와 해당 예외에 대응하는 except 블록으로 이동

---

## 복수 예외 처리
- 발생 가능한 에러마다 처리(같이 적어도 되고, 따로 적어도 됨)

---

## else & finally
- else 블록은 예외가 발생하지 않았을 떄 추가 작업 진행
- finally 블록은 예외 발생 여부와 상관 없이 항상 실행할 코드 작성

---

### 예외 처리 주의사항
- 내장 예외의 상속 계층구조 주의
  - except Exception 이 모든 예외를 먼저 가로채기 때문에, 그 아래에 있는 전용 처리 코드는 실행되지 않음
  - 항상 범용적인 예외 처리(Exception)는 마지막에 두어야 함
- 내장 예외 클래스는 상속 계층 구조를 가지기 때문에 except 절로 분기 시 반드시 하위 클래스를 먼저 확인 할 수 있도록 작성해야 함
- 가장 구체적인 예외부터 처리하고 마지막에 범용 예외를 처리하도록 순서 배치 

---

### 예외 객체 다루기
### as 키워드
- 예외 객체 : 예외가 발생했을 떄 예외에 대한 정보를 담고 있는 객체
- error 변수에 담긴 예외 메시지를 출력하면 구체적인 오류 내용을 쉽게 확인할 수 있음  

### try-except와 if-else
- try-except와 if-else를 함께 사용할 수 있음

---

## EAFP & LBYL
### EAFP(Easier to Ask for Forgiveness than Permission)
- 예외처리를 중심으로 코드를 작성하는 접근 방식(try-except)

### LBYL(Look Bofore You Leap)
- 값 검사를 중심으로 코드를 작성하는 접근 방식(if-else)

## 접근 방식 비교

| 방식   | EAFP ("일단 실행하고 예외를 처리") | LBYL ("실행하기 전에 조건을 검사") |
|--------|------------------------------------|------------------------------------|
| 설명   | 코드를 실행하고 예외가 발생하면 예외처리를 수행 | 코드 실행 전에 조건문 등을 사용하여 예외 상황을 미리 검사하고, 예외 상황을 피하는 방식 |
| 접근 방식 | 코드에서 예외가 발생할 수 있는 부분을 미리 예측하여 대비하는 것이 아니라, 예외가 발생한 후에 예외를 처리 | 코드가 좀 더 예측 가능한 동작을 하지만, 코드가 더 길고 복잡해질 수 있음 |
| 적합한 경우 | 예외 상황을 예측하기 어려운 경우에 유용 | 예외 상황을 미리 방지하고 싶을 때 유용 |

---

## 클래스의 의미와 활용
- 프로그램 규모가 커지면 서로 관련 있는 정보와 기능을 따로따로 관리하기가 점점 어려워짐
- 클래스를 사용하면 관련된 데이터와 기능을 한 덩어리로 묶어 구조를 명확히 할 수 있음
- 이로써 작성한 코드가 훨씬 깔끔해지고 나중에 수정하거나 기능을 추가할 때 더 쉽고 안전해짐