# Data Structure 1

## 데이터 구조란 ? 
- 여러 데이터를 효과적으로 사용 관리하기 위한 구조 
- str, list, dict 등

### 자료 구조
- 컴퓨터 공학에서는 자료 구조라고 함
- 각 데이터의 효율적인 저장, 관리를 위한 구조를 나눠 놓은 것
- 단순히 데이터를 묶는 것을 넘어 프로그램의 성능과 효율성, 유지보수성에 큰 영향을 미치는 핵심적인 개념 

### 데이터 구조의 활용
### 메서드(method)
- 문자열, 리스트, 딕셔너리 등 각 데이터 구조의 메서드를 호출하여 다양한 기능을 활용하기 
- 문자열, 리스트 딕셔너리 등 파이썬의 다양한 데이터 구조는 저마다 고유한 메서드를 가짐
- 이 메서드들은 해당 데이터 구조의 데이터를 효율적으로 조작하거나 특정 기능을 수행하게 위해 제공됨
=> 객체에 속한 함수 (객체가 특정 작업을 수행하도록 정의된 함수)
* 객체 : 특정 데이터(정보)와 그 데이터를 처리하는 기능(메서드)을 하나로 묶은 것

- 메서드는 클래서 내부에 정의되는 함수
- 클래스는 파이선에서 '타입을 표현하는 방법'이며 이미 은연중에 사용해왔음
- 예를 들어 help 함수를 통해 str을 호출해보면 class였다는 것을 확인 가능 

=> 메서드는 어딘가(클래스)에 속해 있는 함수이며 각 데이터 타입별로 다양한 기능을 가진 메서드가 존재

### 메서드 호출 방법
- **데이터 타입 객체.메서드()**
- 우리가 만든 객체(데이터)에게 원하는 명령(메서드)을 내리는 방법

---

## 시퀀스 데이터 구조
### 문자열
### 문자열 조회/탐색 및 검증 메서드 

| 메서드         | 설명                                                                 |
|----------------|----------------------------------------------------------------------|
| `s.find(x)`    | x의 첫 번째 위치를 반환. 없으면 `-1` 반환                             |
| `s.index(x)`   | x의 첫 번째 위치를 반환. 없으면 오류 발생                              |
| `s.isupper()`  | 문자열 내의 모든 문자가 대문자인지 확인                                |
| `s.islower()`  | 문자열 내의 모든 문자가 소문자인지 확인                                |
| `s.isalpha()`  | 문자열 내의 모든 문자가 알파벳인지 확인<br>※ 단순 알파벳이 아닌 유니코드 상 Letter (한국어도 포함) |


### 문자열 조작 메서드(새로운 문자열 반환) => **기존 원본을 바꿀 수 없음! 불변 데이터**

| 메서드                             | 설명                                                                 |
|-----------------------------------|----------------------------------------------------------------------|
| `s.replace(old, new[, count])`    | 바꿀 대상 글자를 새로운 글자로 바꿔서 반환                          |
| `s.strip([chars])`                | 공백이나 특정 문자를 제거                                            |
| `s.split(sep=None, maxsplit=-1)`  | sep을 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를 반환  |
| `'separator'.join(iterable)`      | 구분자로 iterable의 문자열을 연결한 문자열을 반환                   |
| `s.capitalize()`                  | 가장 첫 번째 글자를 대문자로 변경                                   |
| `s.title()`                       | 문자열 내 띄어쓰기 기준으로 각 단어의 첫 글자는 대문자로, 나머지는 소문자로 변환 |
| `s.upper()`                       | 모두 대문자로 변경                                                  |
| `s.lower()`                       | 모두 소문자로 변경                                                  |
| `s.swapcase()`                    | 대 ↔ 소문자 서로 변경                                               |

### .replace(old, new[,count])

- `s.replace(old, new[, count])` : old, new는 필수 인자 []는 선택인자
-> 일치하는 문자를 전부다 바꿈 
```python
text = 'Hello, world! world world'

# 모든 'world'를 'Python'으로 변경
new_text1 = text.replace('world', 'Python')

# 첫 번째 'world'만 'Python'으로 변경
# 세 번째 인자는 갯수
new_text2 = text.replace('world', 'Python', 1)

print(new_text1)  # Hello, Python! Python Python
print(new_text2)  # Hello, Python! world world
```

### s.strip([chars])

- `s.strip([chars])` : **양쪽(왼쪽 + 오른쪽) 끝**에서 지정한 문자들 제거
- 인자를 생략하면 **공백 문자**(`' '`, `'\t'`, `'\n'`, `'\r'`, 등)를 기본 제거

```python
text = '   Hello, world!   '

print(text.strip())          # 'Hello, world!'
print(text.strip('Hd! '))    # 'ello, world'
```

### lstrip() (left strip)
- 왼쪽에서만 문자 제거

```python
text = '   Hello, world!   '

print(text.lstrip())         # 'Hello, world!   '
print(text.lstrip(' H'))     # 'ello, world!   '
```

### rsstrip() (right strip)
- 오른쪽에서만 문자 제거

```python
text = '   Hello, world!   '

print(text.rstrip())         # '   Hello, world!'
print(text.rstrip(' !'))     # '   Hello, world'
```

### 주의할 점
- strip('abc')는 'abc'라는 문자 집합으로 인식 → 'a', 'b', 'c' 각각을 제거
- 중간에 있는 문자는 절대 제거되지 않음



---

### 리스트
### 리스트 값 추가 및 삭제 메서드 **(가변 객체로 원본에 적용돰 => 반환 값이 없음 => 어디 담아서 쓰지 않음)**

| 메서드              | 설명                                                                 |
|---------------------|----------------------------------------------------------------------|
| `L.append(x)`       | 리스트 마지막에 항목 `x`를 추가                                      |
| `L.extend(m)`       | Iterable `m`의 모든 항목들을 리스트 끝에 추가 (`+=`과 같은 기능)     |
| `L.insert(i, x)`    | 리스트 인덱스 `i`에 항목 `x`를 삽입                                  |
| `L.remove(x)`       | 리스트 가장 왼쪽에 있는 항목(첫 번째) `x`를 제거<br>항목이 없으면 `ValueError` 발생 |
| `L.pop()`           | 리스트 가장 오른쪽에 있는 항목(마지막)을 반환 후 제거                |
| `L.pop(i)`          | 리스트의 인덱스 `i`에 있는 항목을 반환 후 제거                       |
| `L.clear()`         | 리스트의 모든 항목 삭제                                               |


### 리스트 탐색 및 정렬 메서드

| 문법               | 설명                                                       |
|--------------------|------------------------------------------------------------|
| `L.index(x)`       | 리스트에서 첫 번째로 일치하는 항목 `x`의 인덱스를 반환     |
| `L.count(x)`       | 리스트에서 항목 `x`의 개수를 반환                           |
| `L.reverse()`      | 리스트의 순서를 역순으로 변경 (정렬 X)                     |
| `L.sort()`         | 리스트를 정렬 (매개변수 이용 가능)                         |

---

## 복사
### 객체와 참조
### 가변/불변 객체의 개념
### Mutable(가변) 객체
- 생성 후 내용을 변경할 수 있는 객체
- 리스트, 딕셔너리, 집합

### Immutable(불변) 객체
- 생성 후 내용을 변경할 수 업는 객체
- 정수, 실수, 문자열, 튜플

### 변수 할당의 의미
- 파이썬에서 변수 할당은 객체에 대한 참조를 생성하는 과정
  - 변수는 객체의 메모리 주소를 가리키는 Label 역할을 함
  - '=' 연산자를 사용하여 변수에 값을 할당
    - 할당 시 새로운 객체가 생성되거나 기존 객체에 대한 참조가 생성됨

- 새로운 객체 생성 후 참조
  - 할당되는 값이 새로운 객체일 경우, 파이썬은 먼저 해당 객체를 메모리에 만들고, 변수가 그 객체를 가리키도록 함 

- 기존 객체에 대한 참조
  - 이미 메모리에 존재하는 객체를 변수에 할당하면 새로운 객체를 만들지 않고 해당 객체에 대한 참조만 생성함 

### 가변 객체 예시 
- 생성 후 내용을 변경할 수 있는 객체 

```python
a = [1, 2, 3, 4]  # 리스트 a 선언
b = a             # b는 a를 "참조" (같은 객체를 가리킴)
b[0] = 100        # b를 수정하면 a도 바뀜

print(a)      # [100, 2, 3, 4]
print(b)      # [100, 2, 3, 4]
print(a is b) # True
```

### 불변 객체 예시
- 생성 후 내용을 변경할 수 없는 객체

```python
a = 20       # a는 정수 20을 가리킴
b = a        # b도 a와 같은 20을 가리킴 (같은 객체)
b = 10       # 이제 b는 10을 가리킴 (새로운 객체 참조)

print(a)      # 20
print(b)      # 10
print(a is b) # False
```

### 가변/불변 메모리 관리 방식
- 가변 객체 
  - 생성 후에도 그 내용을 수정할 수 있음
  - 객체의 내용이 변경되어도 같은 메모리 주소를 유지

- 불변 객체
  - 생성 후 그 값을 변경할 수 없음
  - 새로운 값을 할당하면 새로운 객체가 생성되고 변수는 새 객체를 참조하게 됨

### 가변/불변 메모리 관리 방식의 이유
- 성능 최적화 
  - 불변 객체 : 변경이 불가능하므로, 여러 변수가 동일한 객체를 안전하게 공유할 수 있음
  - 가변 객체 : 내용 수정이 빈번할 때, 새로운 객체를 생성하는 대신 기존 객체를 직접 수정할 수 있음. 이로 인해 객체 생성 및 삭제에 드는 비용을 절감하여 성능을 향상시킴 

- 메모리 효율성
  - 불변 객체 : 동일한 값을 가진 여러 변수가 같은 객체를 참조할 수 있어 메모리 사용을 최소화 할 수 있음
  - 가변 객체 : 크기가 큰 데이터를 효율적으로 수정할 수 있음

---

## 얕은 복사(Shallow Copy)
- 객체의 최상위 요소만 새로운 메모리에 복사하는 방법
- 내주벵 중첩된 객체가 있다면 그 객체의 참조만 복사됨

### TIP 
- 얕은 복사의 함정, '가변 객체'
- 얕은 복사 후 중첩된 리스트나 딕셔너리 같은 가변 객체를 수정하면, 원본 객체와 복사본 객체가 함께 변경됨
- 이는 복사본의 중첩 객체가 여전히 원본 객체의 중첩 객체를 참조하고 있기 때문임

### 얕은 복사 구현 방법
1. 리스트 슬라이싱
2. copy() 메서드
3. list() 함수

### 얕은 복사 예시 - 리스트 슬라이싱
- 리스트 슬라이싱 [:]은 원본 기스트와 동일한 내용의 새로운 리스트를 만듦
- 이때, 새로운 리스트에 복사되는 것은 요소 자체의 값이 아니라 해당 요소들이 참조하는 주소 

### 얕은 복사 예시 - copy() 메서드
- list.copy()은 원본 리스트와 동일한 내용을 가진 새로운 리스트 객체를 반환
- 리스트 슬라이싱([:])과 마찬가지로, 복사된 새 리스트의 요소들은 원본 리스트의 요소들과 동일한 객체들을 참조

### 얕은 복사 예시 - list() 함수

### 얕은 복사의 한계 
- 2차원 리스트와 같이 변경 가능한 객체 안에 변경 가능한 객체가 있는 경우 
  => a와 b의 주소는 다르지만 내부 객체의 주소는 같기 때문에 함께 변경됨

### 1차원 리스트와 다차원 리스트에서의 차이점
- 1차원 리스트 
  - 얕은 복사로 충분히 독립적인 복사본을 만들 수 있음
- 다차원 리스트 
  - 최상위 리스트만 복사되고, 내부 리스트는 여전히 원본과 같은 객체를 참조

---

## 깊은 복사(Deep Copy)
- 객체 모든 수준의 요소를 새로운 메모리에 복사하는 방법
- 중첩된 객체까지 모두 새로운 객체로 생성됨
=> copy 모둘에서 제공하는 deepcopy() 함수를 사용

### TIP
- 완전한 독립성 보장
  - 깊은 복사는 원복 개체와 복사본이 완전히 독립적임을 보장
  - 복사본이 어떤 수준에 있는 중첩된 내용을 변경하더라도 원본 객체에는 절대 영향을 주지 않음

---

## List Comprehension
- 간결하고 효율적인 리스트 생성 방법
  => [experession for 변수 in iterable if 조건식]
  => list(experession for 변수 in iterable if 조건식)

### TIP
- "Pythonic"한 코드
  - 파이썬 개발자들이 선호하는 스타일로, 코드를 더 파이썬답게 작성하는 방법 중 하나 

---

## 메서드 체이닝(Method Chaining)
- 여러 메서드를 연속해서 호출하는 방식

### 메서드 체이닝 주의사항
- 모든 메서드가 체이닝을 지원하는 것은 아님
  - 메서드가 객체를 반환할 때만 체이닝이 가능
- None을 반환하는 메서드는 메서드 체이닝이 불가능
  - ex) 리스트의  append(), sort()
- 메서드 체이닝을 사용할 때는 각 메서드의 반환 값을 잘 이해하고 있어야 함

---

## 문자 유형 판별 메서드
- 문자열에 포함된 문자들의 유형을 판별하는 메서드

- isdecimal()
  - 문자열이 모두 숫자 문자(0~9)로만 이루어져 있어야 True
- isdigit()
  - isdecimal()과 비슷하지만, 유니코드 숫자도 인식
- isnumeric()
  - isdigit()과 우사하지만, 몇 가지 추가적인 유니코드 문자들을 인식
  - 분수, 지수, 루트 기호도 숫자로 인식

