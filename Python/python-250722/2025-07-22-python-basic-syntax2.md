# Python Basic Syntax 2

## 리스트(list)란?

- 여러 개의 값을 순서대로 저장하는 변경 가능한(mutable) 시퀀스 자료형

### 리스트 표현

- 대괄호 [] 안에 값들을 쉼표로 구분하여 만듦
- 숫자, 문자열, 심지어 다른 리스트까지 모든 종류의 데이터를 담을 수 있음
- 값을 추가, 수정, 삭제하는 등 자유롭게 변경할 수 있음

### 리스트와 시퀀스 특징

- 리스트는 시퀀스이므로 문자열처럼 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용
  
### 중첩 리스트(Nested List)란?

- 다른 리스트를 값으로 가진 리스트
*중첩(Nested) : 어떤 자료 구조 안에 같은 종류의 자료 구조가 포함된 형태

### 중첩 리스트 접근하기 
- 인덱스를 연달아 사용하여 안족 리스트의 값에 접근할 수 있음
- 먼저 바깥 리스트의 인덱스로 안쪽 리스트를 선택
- 선택된 안쪽 리스트에 다시 한 번 인덱스를 사용

### 리스트 안에 다양한 타입 허용

- 파이썬의 리스트(`list`)는 **여러 자료형을 섞어서 저장 가능**

```python
python
복사편집
mixed_list = [1, "hello", 3.14, True, [1, 2], {"a": 1}]

```

- 숫자, 문자열, 불리언, 리스트, 딕셔너리 등 **모든 타입 가능**

---

### 리스트 중첩 가능 (이중, 삼중…)

- 리스트 안에 리스트가 얼마든지 들어갈 수 있음

```python
python
복사편집
nested_list = [1, [2, [3, [4]]]]
print(nested_list[1][1][1])  # 출력: 4

```

---

### 문자열도 시퀀스 → 인덱싱 가능

- 문자열도 리스트처럼 인덱스로 접근할 수 있음

```python
python
복사편집
text = "hello"
print(text[1])  # 'e'

my_list = ["apple", "banana"]
print(my_list[0][2])  # 'p' (첫 번째 문자열의 세 번째 문자)

```

### 이유: 파이썬은 동적 타입 언어

- 변수나 리스트에 들어가는 값의 **타입을 고정하지 않음**
- 실행 중에 타입이 결정됨

### 주의사항

- 타입이 섞여 있어도 되지만, **연산 시 타입 오류 주의**

```python
python
복사편집
a = [1, "2"]
print(a[0] + a[1])  # TypeError: unsupported operand types

```
### 리스트의 가변성(Mutability)
- 한 번 생성된 리스트는 "그 내용을 자유롭게 수정, 추가, 삭제할 수 있다"는 뜻. 이는 문자열의 불변성과 정반대되는 매우 중요한 특징

  1. 인덱싱으로 값 수정하기
  2. 슬라이싱으로 여러 값 한 번에 바꾸기

## 파이썬의 가변(Mutable) vs 불변(Immutable) 정리

### 개념 요약

| 구분 | 설명 |
| --- | --- |
| **가변 객체 (Mutable)** | 객체 생성 후 **값을 변경할 수 있음** |
| **불변 객체 (Immutable)** | 객체 생성 후 **값을 변경할 수 없음** (변경 시 새로운 객체 생성) |

---

### 불변(Immutable) 자료형

- 값을 바꾸면 **새로운 객체가 생성**됨
- `id()` 값이 변경됨

```python
python
복사편집
a = 10
print(id(a))  # ex) 140123456
a = a + 1
print(id(a))  # 다른 id로 바뀜 → 새로운 객체

```

### 대표 자료형

| 자료형 | 예시 |
| --- | --- |
| `int` | `a = 10` |
| `float` | `b = 3.14` |
| `bool` | `c = True` |
| `str` | `d = "hello"` |
| `tuple` | `e = (1, 2, 3)` |
| `frozenset` | `f = frozenset([1, 2, 3])` |

---

### 가변(Mutable) 자료형

- 값을 바꿔도 **같은 객체를 유지**함
- `id()` 값이 **변하지 않음**

```python
python
복사편집
lst = [1, 2, 3]
print(id(lst))      # ex) 140123456
lst.append(4)
print(id(lst))      # 그대로 → 내부 값만 변경됨

```

### 대표 자료형

| 자료형 | 예시 |
| --- | --- |
| `list` | `lst = [1, 2, 3]` |
| `dict` | `d = {"a": 1}` |
| `set` | `s = {1, 2, 3}` |
| `bytearray` | `b = bytearray(b"hello")` |
| 사용자 정의 클래스 (기본적으로 가변) | `class MyClass: ...` |

---

### 📎 참고: 문자열의 불변성 예시

```python
python
복사편집
s = "hello"
s[0] = "H"     # TypeError: 'str' object does not support item assignment
s = "Hello"    # 새 문자열로 재할당 (불변이라 가능)

```

## 튜플(tuple)이란?
- 여러 개의 값을 순서대로 저장하는 변경 불가능한 시퀀스 자료형

### 튜플 표현
- 소괄호 () 안에 값들을 쉼표로 구분하여 만듦
- 모든 종류의 데이터를 담을 수 있음
- 리스트와 거의 모든 면에서 비슷하지만, 한 번 만들어지면 절대 수정할 수 없다는 결정적인 차이가 있음
* 소괄호 없이도 만들 수 있음
* 단일 요소 튜플을 만들 때는 반드시 trailling comma(후행 쉼표)를 사용해야 함 

### 튜플의 시퀀스 특징
- 튜플 역시 시퀀스이므로 인덱싱, 슬라이싱, 길이 확인, 반복 등 공통 기능을 모두 사용할 수 있음

### 튜플 변경 시도하기
- 한 번 생성된 튜플은 그 내용을 절대 수정, 추가, 삭제 할 수 없음
- 튜플은 불변이기 떄문에 값을 바꾸고 싶다면 새 튜플을 만들어야 함

## 혼동 주의: 튜플 안에 **가변 객체**가 있을 경우

튜플은 자신이 불변일 뿐이지, **내부에 포함된 가변 객체는 변경될 수 있어요**.

```python
python
복사편집
t = ([1, 2], 3)
t[0].append(99)  # 튜플은 불변이지만, 리스트는 가변이라 가능
print(t)  # 출력: ([1, 2, 99], 3)

```

> 이걸 "shallow immutable"이라고도 해요.
> 
> 
> 튜플 자체는 바뀌지 않지만, 내부에 있는 **가변 요소**는 바뀔 수 있다는 점은 꼭 기억해 두세요!
>

### 튜플은 어디에 쓰일까? (튜필이 불변 자료형인 이유)
- 튜플의 불변 특성을 사용하여 내부 동작과 안전한 데이터 전달에 사용됨
- 다중 할당, 값 교환, 함수 다중 반환 값 등
- 이처럼 튜플은 데이터의 '안정성과 무결성'을 보장함 
- 튜플의 자동패킹/언패킹 기능 

## 튜플이 쓰이는 이유

- **불변성 덕분에 안정적** (함부로 바뀌지 않음)
- **가볍고 빠름** (불필요한 메모리 복사 없음)
- **다중 할당, 다중 반환, 값 교환** 등에서 유용하게 사용됨

## 파이썬 리스트는 왜 위험하고, 튜플은 왜 안전할까?

### 리스트(list)는 가변(Mutable) 객체

- 한 번 생성된 리스트의 **내용을 자유롭게 변경할 수 있음**
- 공유된 리스트는 **어디서든 수정될 수 있기 때문에** 예기치 못한 **부작용(side effect)** 이 발생할 수 있음

```python
python
복사편집
def modify(lst):
    lst.append(100)

my_list = [1, 2, 3]
modify(my_list)
print(my_list)  # [1, 2, 3, 100] → 원본 리스트까지 바뀜

```

---

### 리스트가 위험한 대표 사례들

### 1. 함수 내부에서 원본 변경

- 함수에 리스트를 전달하면, 내부에서 리스트를 바꿨을 때 **원본도 바뀜**

### 2. 디폴트 인자로 리스트를 사용

```python
python
복사편집
def foo(x=[]):
    x.append(1)
    return x

print(foo())  # [1]
print(foo())  # [1, 1] → 계속 누적됨

```

> 디폴트 인자는 함수 정의 시 한 번만 평가되므로, 같은 리스트 객체가 계속 재사용됨
> 

### 3. 데이터 오염 위험

- 리스트를 외부에 전달했다가 내부에서 실수로 수정되면 **예측 불가능한 버그** 발생

---

### 튜플(tuple)은 불변(Immutable) 객체

- 튜플은 한 번 생성하면 **값을 바꿀 수 없음**
- 함수에 전달하거나 디폴트 인자로 써도 **절대 원본이 훼손되지 않음**
- 불변성이 보장되기 때문에 **안정성과 무결성** 유지에 유리함

```python
python
복사편집
t = (1, 2, 3)
# t[0] = 10  TypeError → 값 변경 불가

```

---

### 튜플의 안전한 활용 예시

### 값 교환, 다중 할당에 사용

```python
python
복사편집
a, b = 1, 2
a, b = b, a  # 내부적으로 튜플 생성 및 언패킹

# 실제 동작:
temp = (b, a)
a, b = temp

```

### 함수에서 여러 값 반환

```python
python
복사편집
def get_pos():
    return (10, 20)

x, y = get_pos()

```

---

### 비교 요약표

| 구분 | 리스트 (`list`) | 튜플 (`tuple`) |
| --- | --- | --- |
| 가변성 | 가변 (변경 가능) | 불변 (변경 불가) |
| 원본 수정 위험 | 있음 | 없음 |
| 디폴트 인자 사용 시 | 위험 | 안전 |
| 공유할 때 안정성 | 낮음 | 높음 |
| 값 교환/다중 반환 | 가능 | 가능 |

---

### 핵심 정리 문장

> 리스트는 값이 바뀔 수 있어 공유 시 위험할 수 있지만, 튜플은 불변이라 안정적이고 예측 가능한 코드 작성에 유리하다.
>

## range란?
- 연속된 정수 시퀀스를 생성하는 변경 불가능한(immutable)자료형
- 주로 반복문과 함께 사용되어 특정 횟수만큼 코드를 반복 실행할 때 매우 유용함
- 실제로 모든 숫자를 메모리에 저장하는 대신 시작 값, 끝 값, 간격이라는 '규칙'만 기억하여 메모리를 매우 효율적으로 사용

### range의 기본 구문
- range()는 1개, 2개, 또는 3개의 매개변수(인자)를 가질 수 있음
- range(start, stop, step)
  * 매개변수 : 함수를 정의할 때, 함수가 밭을 값을 나타내는 변수
  * 인자 : 함수를 호출할 때, 실제로 전달되는 값

### range 매개변수별 특징
- range(stop)
  - 매개변수가 하나면 stop으로 인식
  - start는 0이 step은 1이 기본 값으로 자동 설정
  - range(5) -> 0, 1, 2, 3, 4

- range(start, stop)
  - 매개변수가 두 개면 start와 stop으로 인식
  - step 은 1이 기본값으로 자동 설정
  - range(2, 5) -> 2, 3, 4
  
- range(start. stop, step)
  - 모든 매개변수를 직접 지정
  - range(2, 10, 2) -> 2, 4, 6, 8

- range는 list로 형변환 시 내부 값을 확인할 수 있음
- 실제로 모든 숫자를 메모리에 저장하는 대신, 시작값, 끝 값, 간격이라는 규칙만 기억하여 메모리를 효을적으로 사용

- `print(my_range_x)`는 **range 객체만 출력**
- 내부 값을 확인하려면 `list()`로 변환해야 함

### 값의 볌위 규칙
- stop 값은 생성되는 시퀀스에 절대 포함되지 않음
- range(1, 5)는 1부터 5전까지의 숫자를 의미하므로 1, 2, 3, 4가 생성

### 증가/감소 값(step) 규칙
- step 값은 숫자 시퀀스의 간격과 방향을 결정
  1. step이 양수일 때(기본값:1)
     1. 숫자가 start부터 stop을 향해 증가
     2. range(1, 10, 2) -> 1, 3, 5, 7, 9
  2. step이 음수일 때
     1. 수자가 start부터 stop을 향해 감소
     2. 이 경우 start 값은 stop 값보다 반드시 커야 함
     3. range(10, 1, -2) -> 10., 8, 6, 4, 2

- 시작 값이 끝 값보다 크거나 (1알 경우), 시작 값이 끝 값보다 작은 경우(-1일 경우) 에러는 발생하지 않고 생성만 안됨 -> []

### range 활용 예시
- 주로 반복문과 함께 활용 예정

## 딕셔너리(dict)란? 
- key-value 쌍으로 이루어진 순서와 중복이 없는 변경 가능한 자료형 
- 한 쌍이 한 개의 값
- 순서와 중복이 없음 -> sequence x -> 인덱스가 없음
- key 값으로 접근

### 딕셔너리 표현
- 중괄호 {} 안에 값들이 쉼표로 구분되어 있음
- 값 1개는 키와 값이 쌍으로 이루어져 있음
- key(키)
  - 값을 식별하기 위한 고유한 이름표(중복 불가)
- value(값)
  - 키에 해당하는 실제 데이터 
- 각 값에는 순서가 없음

### TIP (딕셔너리의 순서)
- 딕셔너리는 순서가 없는 자료형이지만 파이썬 3.7 이상에서는 입력한 순서는 출력시 그대로 유지됨
- 하지만 여전히 딕셔너리의 핵심은 순서가 없는 자료형이라는 점과 KEY를 통한 접근이라는 점을 기억

## 파이썬 `dict`에서 키와 값의 데이터 타입 제한

###  1. **값(value)**: **타입 제한 없음**

- `int`, `float`, `str`, `list`, `dict`, `set`, `bool`, `None`, 함수 등 **모든 자료형 가능**

```python
python
복사편집
d = {
    "이름": "서린",
    "나이": 24,
    "좋아하는 것": ["코딩", "고양이"],
    "정보": {"학교": "SSAFY", "레벨": 4},
    "함수": lambda x: x + 1
}

```

> ✔ 밸류는 가변/불변 상관없이 다 가능함
> 

---

### 2. **키(key)**: **일부 제한 있음**

- 키는 반드시 **해시 가능(hashable)** 해야 함
- → 즉, **불변(immutable) 객체여야 함**

| 자료형 | 키로 사용 가능? | 이유 |
| --- | --- | --- |
| `int`, `float`, `str`, `bool`, `tuple` (불변) |  가능 | 불변이며 해시 가능 |
| `list`, `dict`, `set` (가변) | 불가능 | 가변 객체는 해시 불가 (`TypeError`) |

```python
python
복사편집
# 가능
d = {42: "정수 키", "name": "문자열 키", (1, 2): "튜플 키"}

# 오류 발생
d = {[1, 2]: "리스트 키"}  # TypeError: unhashable type: 'list'

```

> tuple은 불변이라 키로 사용 가능하지만,
> 
> 
> 내부에 **리스트 같은 가변 요소가 들어있으면** 해시 불가야.
> 

---

## 🔍 왜 키는 불변만 가능할까?

- 딕셔너리는 내부적으로 **해시 테이블(hash table)** 구조를 사용함
- 키를 넣을 때 해시값을 계산해서 저장하는데, **값이 바뀌면 위치도 바뀌어야 해서 혼란**이 생김
- 그래서 **변하지 않는, 고정된 값(불변 객체)**만 키로 허용하는 거야


### Key의 규착
- 고유해야 함 
  - key는 중복될 수 없음
- 변경 불가능한 (immutable) 자료형만 사용 가능 
- 가능 : str, int, float, tuple
- 불가능 : list, dict

### Value의 규칙
- 어떤 자료형이든 자유롭게 사용할 수 있음

-> dict도 중첩이 가능함

### 딕셔너리 값 접근 방법
- key를 사용하여 해당 value를 꺼내 올 수 있음
- key에 접근 시 대괄호 [] 사용
- 존재하지 않는 key로 접근하면 keyerror가 발생하며 프로그램이 멈춤
- 사전에서 단어(key)를 찾아 뜻(value)를 확인하는 것처럼 딕셔너리는 key 를 통해 value에 빠르게 접근함

### 딕셔너리 값 추가 및 변경

- 🔹 **해당 `key`가 없으면** → `key: value`가 새로 **추가**
- 🔹 **해당 `key`가 이미 있으면** → 기존 `value`를 **덮어씀(변경)**

## 실전 TIP

- 키가 있는지 확인하고 추가하거나 변경하고 싶을 때는 조건문과 함께 사용하기도 해요:

```python
python
복사편집
if 'apple' in my_dict:
    print("이미 있음")
else:
    my_dict['apple'] = 999

```

- 또는 `.setdefault()`를 사용하면 "없을 경우에만 추가"도 가능:

### TIP (언제 딕셔너리를 사용할까?)
- 데이터에 순서가 필요 없고, 각 데이터에 있는 의미 있는 이름(KEY)를 붙여 관리하고 싶을 때 사용 
- ex ) 사람이ㅡ 인적 정보, 게임 캐릭터의 능력치 등

## 세트(set)란?
- 순서와 중복이 없는 변경 가능한 자료형 

### 세트 표현
- 중괄호 {} 안에 값들을 쉼표로 구분하여 만듦
- 수학에서의 집합과 동일한 연산 처리 가능
- 빈 세트를 만들때는 dict와 구별 해야하기 때문에 set()로 만듦
- {}로 적으면 dict 취급


### 세트의 두 가지 핵심 특징
1. 중복을 허용하지 않음
   1. 독같은 값은 단 하나만 존재할 수 있음
2. 순서가 없음
   1. 인덱싱이나 슬라이싱을 사용할 수 없음

* set는 집합 연산 할 때 사용 → 중복이 없기 때문에 → 동일한 요소가 있어도 하나로 취급 → 길이도 결과의 길이로 뱉음

### 세트의 집합 연산
- 세트는 수학의 집합 개념을 그대ㅗ 가져와 두 데이터 그룹 간의 관계를 파악하는데 매우 효과적 
- | 합집합 - 차집합 & 교집합

## None이란?
- 파이썬에서 값이 없음을 표현하는 특별한 데이터 타입
- 마치 내용물이 없는 빈 상자와 같음
- 숫자 0이나 빈 문자열('')과는 다른 값이 존재하지 않음 또는 아직 정해지지 않음이라는 상태를 나타내기 위해 사용됨
- 무의 존재는 아님 -> 아직 없다는 것을 표시

## Boolean이란? 
- 참(True)과 거짓(False) 단 두 가지 값만 가지는 데이터 타입
- 프로그램의 흐름을 제어하는 조건문에서 맞다 또는 틀리다를 판단하는 역할을 함
- 비교/논리 연산의 평가 결과로 사용됨 
- 주로 조건/반복문과 함께 사용

## Collection이란?
- 여러 개의 값을 하나로 묶어 관리하는 자료형들을 통칭하는 말
- 여러 물건을 담는 보관함과 같으며 파이썬은 목적에 따라 다양한 종류의 컬렉션을 제공
- str, list, tuple, range, set, dict 데이터 타입이 모두 collection에 분류

| 컬렉션명 | 변경 가능 여부 | 순서 존재 여부 | 분류     |
|----------|----------------|----------------|----------|
| str      | X              | O              | 시퀀스   |
| list     | O              | O              | 시퀀스   |
| tuple    | X              | O              | 시퀀스   |
| dict     | O              | X              | 비시퀀스 |
| set      | O              | X              | 비시퀀스 |


## 불변 vs 가변 
- 컬렉션 타입은 생성 후 내용을 변경할 수 있는지 없는지에 따라 불변과 가변 두 그룹으로 나뉨 
- 불변은 값 자체가 메모리에 들어가 있는 형태라서 쪼개서 수정하거나 하는 것이 안됨 
  
| 구분 | 불변 (Immutable)              | 가변 (Mutable)           |
|------|-------------------------------|---------------------------|
| 특징 | 변경 불가, 안전성, 예측 가능 | 변경 가능, 유연성, 효율성 |
| 종류 | str, tuple, range            | list, dict, set           |


## Shallow Copy vs Deep Copy (얕은 복사 vs 깊은 복사)

### 복사란?

- 파이썬에서 객체를 복사할 때, 겉껍데기만 복사할지 내부까지 완전히 복사할지에 따라 **얕은 복사**와 **깊은 복사**로 나뉜다.
- 특히 **가변 객체(list, dict 등)** 를 다룰 때 중요함.

---

### 🔹 Shallow Copy (얕은 복사)

| 특징 | 설명 |
| --- | --- |
| 구조만 복사 | 바깥쪽 객체(껍데기)만 새로 생성 |
| 내부는 공유 | 내부 요소(리스트, 딕셔너리 등)는 원본과 **공유** |
| 원본 영향 있음 | 내부 데이터를 수정하면 **원본도 같이 변경됨** |

```python
python
복사편집
import copy

a = [[1, 2], [3, 4]]
b = copy.copy(a)
b[0][0] = 999

print(a)  # [[999, 2], [3, 4]]

```

---

### Deep Copy (깊은 복사)

| 특징 | 설명 |
| --- | --- |
| 모든 계층 복사 | 내부까지 재귀적으로 전부 복사 |
| 독립된 객체 | 원본과 **완전히 분리됨** |
| 원본 영향 없음 | 복사본을 수정해도 원본은 **그대로 유지** |

```python
python
복사편집
import copy

a = [[1, 2], [3, 4]]
b = copy.deepcopy(a)
b[0][0] = 999

print(a)  # [[1, 2], [3, 4]]

```

---

### 요약 비교표

| 구분 | 얕은 복사 (Shallow Copy) | 깊은 복사 (Deep Copy) |
| --- | --- | --- |
| 복사 깊이 | 1단계 (껍데기만) | 전체 재귀 복사 |
| 내부 공유 여부 | 공유함 | 완전히 새로 만듦 |
| 원본 영향 | 있음 | 없음 |
| 사용 예 | 성능 중요하거나, 내부 수정 안 할 때 | 안전한 복사 필요할 때 |

---

### 복사 대상이 불변(immutable) 객체인 경우?

- `int`, `str`, `tuple` 등은 **값이 바뀌지 않기 때문에 얕은/깊은 복사 구분이 큰 의미 없음**


## 형변환(Type Conversion)이란? 
- 한 데이터 타입을 다른 데이터 타입으로 변환하는 과정
- 형변환에는 명시적 형변환, 암시적 형변환 두가지가 있음

## 암시적 형변환(Implicit Conversion)이란?
- 파이썬이 연산 중에 자동으로 데이터 타입을 변환하는 것
- 암시적 형변환은 파이썬이 데이터 손실을 막기 위해 더 정밀한 타입으로 자동 변환해주는 규칙
- 마치 작은 정수 상자와 큰 실수 상자의 내용물을 합칠 때 더 안전하게 담을 수 있는 큰 실수 상자로 알아서 옮겨 담는 것과 같음
- 개발자가 신경 쓰지 않아도 더 안전한 쪽으로 파이썬이 처리해줌
- 더 안전한 데이터 타입을 선택해서 연산을 가능하게 함

### 암시적 형변환 예시
- 정수와 실수가 연산에서 정수가 실수로 변환됨
- Boolean과 Numeric Type에서만 가능

## 명시적 형변환(Explicit Conversion)이란?
- 개발자가 변환하고 싶은 타입을 직접 함수로 지정하여 변환하는 것
- 서로 다른 타입의 데이터를 호환되도록 맞추는 과정
- 마치 해외에서 다른 모양의 전기 콘센트에 맞는 어댑터를 끼우는 것과 같음
- 파이썬은 타입에 엄격해서 정수와 문자열을 바로 더할수 없음

| 함수     | 설명         | 예시             | 결과               |
|----------|--------------|------------------|--------------------|
| int()    | 정수로 변환  | int("123")       | 123                |
| float()  | 실수로 변환  | float("3.14")    | 3.14               |
| str()    | 문자열로 변환| str(100)         | "100"              |
| list()   | 리스트로 변환| list("abc")      | ['a', 'b', 'c']    |
| tuple()  | 튜플로 변환  | tuple([1,2])     | (1, 2)             |
| set()    | 세트로 변환  | set([1,2,2])     | {1, 2}             |

- str -> int : 형식에 맞는 숫자만 가능
- int -> str : 모두 가능

### 컬렉션 간 형변환 정리 
|        | str | list | tuple | range | set  | dict     |
|--------|-----|------|-------|-------|------|----------|
| str    | O   | O    | O     | X     | O    | X        |
| list   | O   | O    | O     | X     | O    | O (key만)|
| tuple  | O   | O    | O     | X     | O    | O (key만)|
| range  | O   | O    | O     | O     | O    | X        |
| set    | O   | O    | O     | X     | O    | X        |
| dict   | O   | O    | O     | X     | O    | O (key만)|


## 산술 연산자
- 수학적 계산을 위해 사용되는 연산자 
| 기호  | 연산자         |
|-------|----------------|
| -     | 음수 부호       |
| +     | 덧셈           |
| -     | 뺄셈           |
| *     | 곱셈           |
| /     | 나눗셈         |
| //    | 정수 나눗셈 (몫) |
| %     | 나머지         |
| **    | 지수 (거듭제곱) |

## 복합 연산자(대입 연산자)
  - 연산과 할당이 함께 이루어짐
| 기호  | 예시       | 의미             |
|-------|------------|------------------|
| +=    | a += b     | a = a + b        |
| -=    | a -= b     | a = a - b        |
| *=    | a *= b     | a = a * b        |
| /=    | a /= b     | a = a / b        |
| //=   | a //= b    | a = a // b       |
| %=    | a %= b     | a = a % b        |
| **=   | a **= b    | a = a ** b       |


## 비교 연산자
- 두 값을 비교하여 그 관계가 맞는지 틀리는지를 True 또는 False로 반환
| 기호     | 내용       |
|----------|------------|
| <        | 미만       |
| <=       | 이하       |
| >        | 초과       |
| >=       | 이상       |
| ==       | 같음       |
| !=       | 같지 않음  |
| is       | 같음       |
| is not   | 같지 않음  |


## == 연산자
- 값(데이터)이 같은지를 비교
- 동등성(equality)
- 예를 들어 1 == True의 경우 파이썬이 내부적으로 True를 1로 간주할 수 있으므로 True가 나옴

## is 연산자
- 객체 자체가 같은지를 비교
- 식별성(identity)
- 두 변수가 완전히 동일한 객체를 가리키는지 즉 메모리 주소가 같은지를 확인할 때 사용

### is 대신 ==를 사용해야 하는 이유
- 결론 : is는 정체성을 ==는 가치를 비교하기 때문
- 두 연산자는 같다르 ㄹ확인하는 목적이 근본적으로 다름
- is(idenity operator)
  - 두 변수가 완전히 동일한 메모리 주소의 객체를 가리키는지 즉 정체성이 같은지를 확인
- ==(equality operator)
  - 두 변수가 가리키는 객체의 내용, 즉 값이 같은지를 확인

### is를 값 비교에 사용하면 안되는 이유 : 의도와 다른 결과름 낳음
- 두 객체의 값이 논리적으로 같은가를 위해서는 ==를 사용해야 의도에 맞음 

### is 연산자는 언제 사용?
- 주로 싱글턴 객체를 비교할 때 사용

### 싱글턴(Sigleton) 객체란?
- 특정 값에 대해 파이썬 전체에서 단 하나의 객체만 생성되어 재사용되는 특별한 객체
- 여러 변수가 이 값을 가지더라도 모두 미리 만들어진 하나의 객체를 함께 가리키게 되므로 항상 같은 메모리 주소를 가짐
- 파이썬의 대표적인 싱글턴 객체 : None, True, False

### 싱글턴 객체를 비교할 때
- is 연산자는 두 변수가 완전히 동일한 객체르 락리키는지, 즉 메모리 주소가 같은지를 확인할 때 사용
- 파이썬 전체에서 단 하나의 객체만 생성되어 재사용 되는 싱글턴 객체 비교에 적합 

### 리스트나 객체 비교 시 주의사항
- 리스트 또는 다른 가변 객체(mutable)를 비교할 때 값 자체가 같은지 확인하려면 ==를 사용
- 두 변수가 완전히 동일한 객체를 가리키는지 확인해야 한다면 is를 사용

### ==와 is 정리
- 값 비교에는 ==를 사용하고 객체(레퍼런스) 비교에는 is를 사용하는 것이 원칙
- 숫자나 문자열, 불리언 값 등 동등성(값)을 판단해야 할 때 is를 쓰면 의도치 않은 결과(False)가 나올 수 있으며, 이는 파이썬 내부적인 최적화나 타입 차이로 인해 일관성이 깨질 수 있기 때문 
- is 는 주로 싱글턴 객체에 대한 비교시 사용

## 논리 연산자
- 여러 개의 조건을 조합하거나 True/False 값을 반대로 뒤집을 때 사용(and. or, not이 대표적)
| 기호 | 연산자   | 내용                                                  |
|------|----------|-------------------------------------------------------|
| and  | 논리곱   | 두 피연산자 모두 True인 경우에만 전체 표현식을 True로 평가 |
| or   | 논리합   | 두 피연산자 중 하나라도 True인 경우 전체 표현식을 True로 평가 |
| not  | 논리부정 | 단일 피연산자를 부정                                   |


## 단축 평가란?
- 논리 연산에서 두 번째 피연산자를 평가하지 않고 결과를 결정하는 동작 
- 꼭 필요한 계산만 하고 결과가 이미 정해졌다면 굳이 뒤에 있는 코드까지 확인하지 않음

### 파이썬에서의 참과 거짓
- 거짓으로 취급되는 값들
  - False, 숫자 0, 빈 문자열 '', 빈 리스트 [], None 등 비어있거나 없다는 느낌의 값들
- 참으로 취급되는 값들
  - True 그리고 거짓이 아닌 모든 값
  - 내용이 있는 값들

### 단축 평가 동작 원리
- and 연산자
  - 하나라도 거짓이면 바로 거짓
  - and는 연산을 왼쪽에서 오른쪽으로 진행하다가 처음 만나는 거짓 값을 바로 반환
  - 만약 끝까지 갔는데 모든 값이 참이면 맨 마지막 참 값을 반환

- or 연산자
  - 하나라도 참이면 바로 참
  - or은 연산을 왼쪽에서 오른쪽으로 진행하다가 처음 만나는 참 값을 바로 변환
  - 만약 끝까지 갔는데 모든 값이 거짓이면 맨 마지막 거짓 값을 반환

### 단축 평가를 하는 이유
- 코드 실행을 최적화하고, 불필요한 연산을 피할 수 있도록 함
- 단순히 True/False 논리 연산을 넘어 이처럼 코드의 흐름을 제어하고 오류를 방지하며 간결한 코드를 작성하는 데 매우 유용하게 사용되는 파이썬의 중요한 기능

## 멤버십 연산자
- 특정 값이 시퀀스나 다른 컬렉션 안에 포함되어 있는지 확인하는 연산자
- 포함 관계 판단
| 기호     | 내용                                                                 |
|----------|----------------------------------------------------------------------|
| in       | 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하는지를 확인           |
| not in   | 왼쪽 피연산자가 오른쪽 피연산자의 시퀀스에 속하지 않는지를 확인      |


## 시퀀스형 연산자 
- 시퀀스 자료형(문자열, 리스트 튜플)에 특별한 의미로 사용되는 연산자
- '+'는 시퀀스를 연결하는 기능을 '*'는 시퀀스를 반복하는 기능을 함
| 연산자 | 내용       |
|--------|------------|
| +      | 결합 연산자 |
| *      | 반복 연산자 |
 
### 연산자 우선 순위 
| 우선순위 | 연산자                         | 내용                        |
|----------|-------------------------------|-----------------------------|
| 높음     | ()                            | 소괄호 grouping             |
|          | []                            | 인덱싱, 슬라이싱           |
|          | **                            | 거듭제곱                   |
|          | +, -, ~                       | 단항 연산자 양수/음수      |
|          | *, /, //, %                   | 산술 연산자                 |
|          | +, -                          | 산술 연산자                 |
|          | <, <=, >, >=, ==, !=          | 비교 연산자                 |
|          | is, is not                    | 객체 비교                   |
|          | in, not in                    | 멤버십 연산자               |
|          | not                           | 논리 부정                   |
|          | and                           | 논리 AND                    |
| 낮음     | or                            | 논리 OR                     |



## Trailing Comma(후행 쉼표)
- 컬렉션의 마지막 요소 뒤에 붙는 쉼표
- 일반적으로 선택사항
- 단 하나의 요소로 구성된 튜플을 만들 때는 필수

### Trailing Comma 기본 규칙
- 각 요소를 별도의 줄에 작성
- 마지막 요소 뒤에 trailing comma 추가
- 닫는 괄호는 새로운 줄에 배치

### Trailing Comma 장점
1. 가독성 향상
   1. 각 줄이 동일한 패턴을 가짐
   2. 코드 리뷰가 용이함
2. 유지 보수 용이성
   1. 항목 추가/제거가 간단
   2. 실수로 인한 구분 오류 방지 
   
## 핵심 키워드 정리
| 개념            | 설명                                                             | 예시                                      |
|-----------------|------------------------------------------------------------------|-------------------------------------------|
| 리스트 (List)   | 순서가 있고, 수정 가능한 값들의 묶음                              | my_list = ['1', 'a', True]                |
| 딕셔너리 (dict) | 순서 없이 Key-Value 쌍으로 이루어진 데이터 묶음                   | my_dict = {'사과': 1500, '바나나': 3000}  |
| 형 변환         | 데이터의 타입을 의도적으로 변경하는 것                            | int('123'), str(3.14)                     |
| Boolean         | 참(True) 또는 거짓(False)을 나타내는 데이터 타입                  | is_student = True                         |
| 멤버십 연산자   | 특정 값이 컬렉션에 포함되어 있는지 확인하는 연산자                | 'apple' in fruit_basket                   |
| 논리 연산자     | 여러 조건을 연결(and, or)하거나 부정(not)시키는 연산자             | if age > 19 and has_ticket:               |
| 단축 평가       | 논리 연산자의 전체 조건을 평가하지 않고 일부만 평가하는 특징      | True or (some_complex_function())         |
